<!DOCTYPE html>
<html lang="fr-fr">

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="Abdelmajid OUMNAD" name="author">
    <meta content="Electronique Num√©rique" name="description">
    <meta content="Binaire, Hexad√©cimal, Porte logique, Bascule, JK, RS, Compteur, Multiplexeur, Additionneur"
        name="keywords">
    <title>Electronique Num√©rique</title>
    <link rel="icon" href="IMAGES/ElecLogo.png" type="image/png">
    <link rel="stylesheet" href="../styles.css">
    <script src="../scripts.js" defer></script>
    <script id="mathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
    <div class="TwoPanPageContainer">
        <div id="LeftPanel_ID" class="LeftPanel">
            <div class="LeftPanelHeader">
                <img src="../IMAGES/x3.png" id="XIcon" class="xicon Burger">
                <a href="../index.html"> <img src="../IMAGES/home48.png" alt=""> </a>
                <a href="Electronique.html"> <img src="IMAGES/ElecLogo.png" height="45px"> </a>
            </div>
            <div id="LeftPanelMenu_ID" class="LeftPanelMenu">

                <div class="rubrique" onclick="toggleMenu('numbers', this)">
                    <span>&gt;</span>
                    <h2>Representation des nombres</h2>
                </div>
                <div id="numbers" class="sub-rubrique">
                    <a href="#INTRO">
                        <h3>Syst√®mes pond√©r√©s</h3>
                    </a>
                    <a href="#BINARY">
                        <h3>Int√©r√™t du syst√®me binaire</h3>
                    </a>
                    <a href="#CONVBASE">
                        <h3>Changement de base</h3>
                    </a>
                    <a href="#CALCBIN">
                        <h3>Calcul dans le syst√®me binaire</h3>
                    </a>
                    <a href="#REPNEG">
                        <h3>La repr√©sentation des nombres n√©gatifs</h3>
                    </a>
                    <a href="#CODES">
                        <h3>Autres Representations</h3>
                    </a>
                    <a href="#GRAY">
                        <h3>Le code Gray</h3>
                    </a>


                </div>
                <div class="rubrique" onclick="toggleMenu('boole', this)">
                    <span>&gt;</span>
                    <h2>Alg√®bre de Boole</h2>
                </div>
                <div id="boole" class="sub-rubrique">
                    <a href="#BOOLE">
                        <h3>Introduction</h3>
                    </a>
                    <a href="#VARLOGIC">
                        <h3>Variables Bool√©enne</h3>
                    </a>
                    <a href="#FONCLOGIC">
                        <h3>Fonctions Bool√©enne</h3>
                    </a>
                    <a href="#OPLOGIC">
                        <h3>Op√©rateurs logiques</h3>
                    </a>
                    <a href="#IDENTREM">
                        <h3>Identit√©s remarquables</h3>
                    </a>
                    <a href="#MORGAN">
                        <h3>Th√©or√®me de Morgan</h3>
                    </a>
                    <a href="#CANONIC">
                        <h3>Forme Canonique</h3>
                    </a>
                    <a href="#NANDUNIVERSEL">
                        <h3>NAND : Op√©rateur universel</h3>
                    </a>
                </div>

                <div class="rubrique" onclick="toggleMenu('simpfonc', this)">
                    <span>&gt;</span>
                    <h2>Simplification des fonctions logiques</h2>
                </div>
                <div id="simpfonc" class="sub-rubrique">
                    <a href="#SIMPFONC">
                        <h3>Introduction</h3>
                    </a>

                    <a href="#DKARNAUGH">
                        <h3>Diagramme de Karnaugh</h3>
                    </a>
                    <a href="#REMPKAR">
                        <h3>Remplissage de la table de Karnaugh</h3>
                    </a>
                    <a href="#GROUP">
                        <h3>Regrouper les 1 en blocs</h3>
                    </a>
                    <a href="#LECTCARNAUGH">
                        <h3>Lecture de la table de Karnaugh</h3>
                    </a>
                    <a href="#KEX1">
                        <h3>Exemple 1: Binaire &xrarr; Gray</h3>
                    </a>
                    <a href="#KEX2">
                        <h3>Exemple 2: Etude d'un convoyeur</h3>
                    </a>
                </div>
                <br><br><br>
                <h2>Le reste est en cours de redaction</h2>


            </div>
        </div>

        <!-- ################################################################################################ -->
        <div class="RightPanel">
            <div class="RightPanelHeader">
                <img onclick="montrerMenu()" class="Burger CursorPointer" src="../IMAGES/menu48.png">
                <h1>Electronique Num√©rique</h1>
            </div>
            <div class="RightPanelContent">



                <!-- ################################################################################################ -->
                <h2 id="INTRO">Representation des nombres</h2>
                <p>La repr√©sentation naturelle que nous utilisons pour repr√©senter des nombres est une repr√©sentation
                    <b>pond√©r√©e</b>. Les syst√®mes <b>D√©cimal</b> de base <i>B=10</i>, <b>Octal</b> de base <i>B=8</i>,
                    Hexad√©cimal de base <i>B=16</i> et <b>Binaire</b> de base <i>B=2</i> sont des syst√®mes pond√©r√©s
                </p>
                <p>un syst√®me pond√©r√© de base B est caract√©ris√© par :</p>
                <ul>
                    <li>Il faut B symboles qu'on appelle <b>chiffres</b> pour repr√©senter un nombre dans une bas B. Par
                        exemple :
                        <ul>
                            <li>Le syst√®me D√©cimal utilise dix chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</li>
                            <li>Le syst√®me Octal utilise 8 chiffres : 0, 1, 2, 3, 4, 5, 6, 7</li>
                            <li>Le syst√®me Hexad√©cimal utilise 16 chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D,
                                E, F</li>
                            <li>Le syst√®me Binaire utilise 2 chiffres : 0, 1</li>
                        </ul>
                    </li>
                    <li>Chaque chiffre a une "poids" qui d√©pend de sa position dans le nombre </li>
                    <li>Chaque poids est une puissance de B</li>
                    <li>A gauche de la virgule (.d√©cimal), on a les puissances positives de B. A droite on a les
                        puissances n√©gatives</li>
                    <li>Le poids du chiffre de rang i est B fois celui du rang i-1 <br>
                        <img src="IMAGES/EN_Poids.jpg" alt="">
                    </li>
                    <li>Exemples :
                        <ul>
                            <li>Le nombre 472 en base 10 peut √™tre d√©compos√© comme suit : <br>
                                \( 472_{10}= 4 √ó 10^2 + 7 √ó 10^1 + 2 √ó 10^0 \)</li>
                            <li>Le nombre 345.25 en base 10 peut √™tre d√©compos√© comme suit : <br>
                                \( 345.25_{10}= 3 √ó 10^2 + 4 √ó 10^1 + 5 √ó 10^0 + 2 √ó 10^{-1} + 5 √ó 10^{-2} \)</li>
                            <li>Le nombre binaire 1011 peut √™tre converti en d√©cimal comme suit : <br>
                                \( 1101_2 =1√ó2^3 + 1√ó2^2 +0√ó2^1 +1√ó2^0=1√ó8+1√ó4+0√ó2+1√ó1=8+4+0+1=13_{10} \)</li>
                            <li>Le nombre binaire 101.101 peut √™tre converti en d√©cimal comme suit : <br>
                                \( 101.101_2 =1√ó4 + 0√ó2 + 1√ó1 + 1√ó0.5 + 0√ó0.25 + 1√ó0.125 = 5.625_{10} \)</li>
                            <li>Le nombre hexad√©cimal 2F3 peut √™tre converti en d√©cimal comme suit : br</li>
                            \( 2F3_{16}= 2√ó16^2 +F√ó16^1 +3√ó16^0 = 2√ó256+15√ó16+3√ó1=755_{10} \)
                        </ul>

                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h2 id="BINARY">Int√©r√™t du syst√®me binaire</h2>
                <p>Le syst√®me binaire rev√™t une importance fondamentale en √©lectronique et en informatique,
                    principalement parce qu'il est ais√©ment transposable en signaux √©lectriques. En effet, les deux
                    √©tats possibles du syst√®me binaire, repr√©sent√©s par les chiffres 0 et 1, peuvent √™tre mat√©rialis√©s
                    de diverses mani√®res techniques, permettant ainsi de simplifier la conception et la fabrication des
                    circuits √©lectroniques. Parmi ces m√©thodes, on peut citer :
                </p>
                <ul>
                    <li>Le passage ou non d'un courant √©lectrique dans un composant** : un circuit peut √™tre con√ßu pour
                        d√©tecter la pr√©sence (repr√©sentant "1") ou l'absence (repr√©sentant "0") d'un courant √©lectrique,
                        une approche couramment utilis√©e dans les circuits logiques</li>
                    <li>L'√©tat d'un commutateur** : par exemple, un transistor ou un autre type de dispositif peut agir
                        comme un interrupteur, qui est soit ouvert (repr√©sentant "0"), soit ferm√© (repr√©sentant "1").
                        Cette caract√©ristique est essentielle pour le fonctionnement des circuits int√©gr√©s et des
                        microprocesseurs
                        modernes</li>
                    <li>La valeur d'une tension √©lectrique** : une tension sp√©cifique peut √™tre attribu√©e √† chaque √©tat
                        binaire. Par exemple, une tension de +5 volts peut correspondre √† "1", tandis qu'une tension de
                        0 volt peut correspondre √† "0". Cette m√©thode est particuli√®rement r√©pandue dans les syst√®mes
                        num√©riques pour transmettre des informations de mani√®re fiable</li>
                </ul>
                <p>Ces repr√©sentations permettent une mise en ≈ìuvre robuste et efficace des syst√®mes num√©riques, qui
                    forment la base des technologies modernes, des ordinateurs aux syst√®mes embarqu√©s en passant par les
                    t√©l√©communications.</p><br>

                <!-- ################################################################################################ -->
                <h2 id="CONVBASE">Changement de base</h2>
                <p>La conversion entre les syst√®mes dont la base est une puissance de v2 est tr√®s facile. Le conversion
                    de ou vers la base 10 demande un peu plus de travail</p>
                <h3>Hexad√©cimal &xrarr; binaire</h3>
                <p>chaque chiffre Hexad√©cimal est √©crit sur 4 bits :</p>
                <p>8E97A<sub>16</sub> = 1000 1110 1001 0111 1010<sub>2</sub> </p>

                <h3>Octal &xrarr; binaire</h3>
                <p>chaque chiffre octal est est √©crit sur 3 bits :</p>
                <p>657<sub>8</sub> = 110 101 111<sub>2</sub> </p>

                <h3>Binaire &xrarr; Hexad√©cimal</h3>
                <p>Le nombre binaire est d√©coup√© en blocs de 4 bits en commen√ßant de la droite (LSB), ensuite chaque
                    bloc de 4 bits est repr√©sent√© en hexad√©cimal</p>
                <p>11110111110011011<sub>2</sub> = 1 1110 1111 1001 1011<sub>2</sub> = 1EF9B<sub>16</sub> </p>

                <h3>Decimal &xrarr; Binaire</h3>
                <p>La m√©thode la plus automatique et la division/multiplication en √©chelle.</p>
                <p>Pour la partie enti√®re, on effectue une division successive par 2. On arr√™te quand on a un quotient
                    nul. Le r√©sultat en binaire est constitu√© par les restes successifs des divisions.
                </p>
                <p>Pour la partie d√©cimale, on proc√®de √† des multiplications successives par 2. Le processus s'arr√™te
                    d√®s qu'un produit entier est obtenu. Toutefois, il peut arriver que l'on n'obtienne jamais de
                    produit entier, dans ce cas, la multiplication peut th√©oriquement se poursuivre ind√©finiment.
                    Dans une telle situation, on peut choisir de s'arr√™ter d√®s que l'on estime que le nombre de chiffres
                    apr√®s la virgule est suffisant.</p>
                <h4>Exemple :</h4>
                <p>On va convertir le nombre 947,6407 en binaire</p>
                <p>Pour la partie enti√®re on obtient :</p>
                <img src="IMAGES/EN_DivEch.jpg" alt="">
                <p>Pour la partie d√©cimale :</p>
                <img src="IMAGES/EN_MulEch.jpg" alt="">
                <p>le r√©sultat final est : <b><i>947,6407=<span class="blue">1110110011</span>.<span
                                class="red">101001</span> </i></b></p>

                <p> </p>

                <!-- ################################################################################################ -->
                <h2 id="CALCBIN">Calcul dans le syst√®me binaire</h2>
                <p>Le calcul dans le syst√®me binaire se fait de la m√™me fa√ßon que nous avons appris √† le faire en
                    d√©cimal dans la petite √©cole.</p>
                <h3>Addition :</h3>
                <p>
                    0 + 0 = 0 <br>
                    0 + 1 = 1 <br>
                    1 + 0 = 1 <br>
                    1 + 1 = 0 et on retient 1
                </p>
                <img src="IMAGES/EN_AddBin.jpg" alt="">
                <p>On remarque dans l'exemple qu'√† cause de la retenue du rang pr√©c√©dent, on est amen√© √† ajouter 3
                    bits. On en d√©duit qu'un additionneur √©l√©mentaire doit additionner 3 bits et produire une somme et
                    une retenue. Nous reviendrons plus en d√©tail sur cet aspect dans la section consacr√©e aux circuits
                    num√©riques.</p><br>

                <h3>Soustraction :</h3>
                <p>
                    0 - 0 = 0 <br>
                    0 - 1 = 1 apr√®s avoir emprunt√© 1 √† la rang√©e de gauche<br>
                    1 - 0 = 1 <br>
                    1 - 1 = 0 <br>
                </p>
                <img src="IMAGES/EN_SubBin.jpg" alt="">
                <p>Avec la soustraction, m√™me s'il arrive qu'on parle de retenue, en fait c'est un emprunt (Borrow en
                    anglais). On
                    constate sur l'exemple qu'√† chaque colone, on effectue une soustraction de 3 bites \((X - Y -
                    B_{in})\) et on produit un r√©sultat \(S\) et un Borrow \(B_{out}\). Le
                    tableau ci-dessous r√©pertorie toutes les possibilit√©s </p>
                <img src="IMAGES/EN_Sub_Bin_Table.jpg" alt="">
                <p> Nous reviendrons plus en d√©tail sur cet aspect dans la section consacr√©e aux circuits
                    num√©riques.</p><br>

                <h3>Multiplication :</h3>
                <p>L√† aussi, on proc√®de comme on le fait en base 10</p>
                <img src="IMAGES/EN_MulBin.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="REPNEG">La repr√©sentation des nombres n√©gatifs</h2>

                <p>Il existe plusieurs fa√ßons de repr√©senter les nombres n√©gatifs en binaire.
                    La plus utilis√©e en informatique est la m√©thode du <em>compl√©ment √† deux</em>. Cette technique
                    repose sur une
                    propri√©t√© fondamentale : le compl√©ment (-N) d'un nombre N est d√©fini de mani√®re √† v√©rifier l'√©galit√©
                    suivante : \(N+(-N)=0\)</p>
                <p>Cependant, en binaire, cette m√©thode n'a de sens que si l'on travaille avec un nombre fixe de bits,
                    ce qui correspond √† la taille des registres ou des donn√©es manipul√©es par une machine.
                    Prenons l'exemple d'une machine qui utilise 4 bits pour repr√©senter les nombres. Cette machine peut
                    repr√©senter uniquement les nombres compris entre 0000 (0 en base 10) et 1111 (15 en base 10).

                    Examinons quelques op√©rations :</p>
                <ul>
                    <li>Si l'on effectue l'addition 0101 (5) + 0011 (3), on obtient 1000 (8). Le r√©sultat est correct et
                        reste dans la plage repr√©sentable.</li>
                    <li>En revanche, si l'on effectue 0111 (7) + 1101 (13), on obtient 0100 (4). Pourquoi? Parce que la
                        machine n'a pas de place pour le cinqui√®me bit g√©n√©r√© par l'op√©ration, qui correspondrait √† 16.
                        Ce d√©passement est appel√© un d√©bordement.</li>
                </ul>
                <p>Ce comportement implique qu'une machine 4 bits effectue ses calculs modulo \(2^4=16\).
                    Dans ce syst√®me, <b>le nombre 16 est √©quivalent √† 0</b>. Par cons√©quent, la m√©thode du compl√©ment √†
                    deux repose sur la relation :
                    $$N+(-N)=16$$
                    Le compl√©ment du nombre N est donc :
                    $$(-N)=16-N$$
                    D'une fa√ßon g√©n√©rale, dans une machine n bits, le compl√©ment d'un nombre N est donn√© par :
                    $$(-N)=2^n-N$$
                </p>
                <p>Cette d√©finition garantit que l'addition de N et de son compl√©ment donne toujours z√©ro</p>
                <p>Le compl√©ment √† 2 d'un nombre peut √™tre d√©termin√© directement en binaire sans passer par les
                    relations ci-dessus.</p>
                <p>En effet :</p>
                $$(-N)=16-N=(15+1)-N=(15-N)+1$$
                <p>L'op√©ration \(15-N\) s'appelle <em>le compl√©ment √† 1</em> du nombre N. Elle revient √† compl√©menter un
                    par
                    un tous les bits du nombre N. Ensuite, il suffit d'ajouter 1 pour obtenir Le <em>Le compl√©ment √†
                        2</em></p>

                <h4>Exemple :</h4>
                <p>Cherchons la repr√©sentation du nombre (-7) :</p>
                <ul>
                    <li> 7 = 0111</li>
                    <li>On inverse tous les bits &xrarr; 1000</li>
                    <li> On ajoute 1 &xrarr; -7 = 1001</li>
                    <li>v√©rification (7) + (-7) :
                        <img class="inline" src="IMAGES/EN_C2Verif.jpg" alt="">
                    </li>
                </ul><br>
                <p>En d√©finitif, notre machine 4 bits peut repr√©senter \(2^4=16\) nombres diff√©rents : </p>
                <ul>
                    <li>Soit non sign√©s (tous positifs)
                        <img src="IMAGES/EN_Unsigned.jpg" alt="">
                    </li>
                    <li>Soit sign√©s, 8 positifs et 8 n√©gatifs :
                        <img src="IMAGES/EN_SignedTable.jpg" alt=""><br>
                        Remarquons que pour les nombres positifs, le MSB est √©gal √† 0 et pour les nombres n√©gatifs le
                        MSB est
                        √©gal √† 1. C'est ainsi que l'on peut tester si le r√©sultat d'une op√©ration est juste. Par
                        exemple,
                        pour l'addition, la r√®gle est simple :
                        <ul>
                            <li>La somme de 2 nombres positifs doit donner un nombre positif</li>
                            <li>la somme de 2 nombres n√©gatifs doit donner un nombre n√©gatif</li>
                        </ul>
                        L'erreur se produit quand il y a d√©bordement, c.a.d quand le r√©sultat d√©passe le nombre maximum
                        que
                        la machine peut repr√©senter soit +7 pour les nombres positifs ou -8 pour les nombres n√©gatifs.
                        Une
                        erreur peut se produire quand on ajoute des nombres de m√™me signe. Il y a erreur quand le signe
                        du
                        r√©sultat est diff√©rent de celui des deux op√©randes.
                        <img src="IMAGES/EN_SignedExmples.jpg" alt="">
                    </li>
                </ul><br>


                <h4>G√©n√©ralisation :</h4>
                <div class="encadre">
                    <ul>
                        <li>Une machine \(n\) bits peut repr√©senter \(2^n\) nombres diff√©rents :</li>
                        <li>Si on ne d√©sire manipuler que des nombres positifs, on pourra repr√©senter les nombres allant
                            de \(0\) √† \(2^n-1\) </li>
                        <li>Si on d√©sire manipuler des nombres sign√©s, on pourra repr√©senter :
                            <ul>
                                <li>\(\frac{2^n}{2}\) Nombres positifs allant de \(\quad 0 \quad √† \quad
                                    \left(\frac{2^n}{2}-1\right) \)</li>
                                <li>\(\frac{2^n}{2}\) Nombres n√©gatifs allant de \(\quad -1 \quad √† \quad -\frac{2^n}{2}
                                    \)</li>
                            </ul>
                        </li>
                    </ul>
                </div>




                <!-- ################################################################################################ -->
                <h2 id="CODES">Autres Representations</h2>
                <p>Le binaire naturel n'est pas la seule repr√©sentation des nombres utilis√©e en informatique.
                    Bien que le syst√®me binaire naturel (ou positionnel) soit largement employ√© pour repr√©senter les
                    nombres en raison de sa simplicit√© et de son ad√©quation avec le fonctionnement des circuits
                    √©lectroniques, d'autres syst√®mes de codage peuvent √™tre mieux adapt√©s √† certains contextes
                    sp√©cifiques. Parmi ces syst√®mes, on trouve :</p>
                <ul>
                    <li><b>Le code BCD</b> (Binary-Coded Decimal) : Ce syst√®me repr√©sente chaque chiffre d√©cimal
                        individuellement √†
                        l'aide de 4 bits. Par exemple :
                        <ul>
                            <li>\( 457 = 111001001_{binaire} \)</li>
                            <li>\( 457 = 0100 \; 0101 \; 0111_{BCD} \)</li>
                        </ul>
                        Le code BCD est couramment utilis√© dans les syst√®mes avec des afficheurs Sept segments
                        <img src="IMAGES/EN_7seg.jpg" alt="">
                    </li>
                    <li><b>Le code de Gray</b> : Utilis√© principalement dans les syst√®mes de mesure et de contr√¥le. Ce
                        code a la particularit√© de ne changer qu'un seul bit entre deux valeurs cons√©cutives. Cela le
                        rend particuli√®rement adapt√© aux dispositifs o√π des erreurs dues √† des transitions multiples de
                        bits
                        pourraient survenir, comme dans les codeurs rotatifs ou les circuits num√©riques synchrone. Il
                        est aussi utilis√© dans les tables de Karnaugh pour la simplification des fonctions logiques</li>
                    <li>Le code exc√®s-N (Excess-N) : Utilis√© pour repr√©senter des nombres sign√©s ou non sign√©s. Il est
                        courant dans certains formats d'images num√©riques ou d'intervalles d√©finis.

                    </li>
                </ul>
                <p>Ces syst√®mes de codage, bien que moins universels que le binaire naturel, r√©pondent √† des
                    besoins sp√©cifiques en optimisant certains aspects comme la lisibilit√© humaine (BCD), la robustesse
                    contre les erreurs (code de Gray) ou la gestion de plages num√©riques particuli√®res (exc√®s-N). Ainsi,
                    le choix d'un syst√®me d√©pend largement des contraintes et des exigences de l'application envisag√©e
                </p>
                <p>Le tableau ci-dessous pr√©sente l'exemple de quelques codes :</p>
                <img src="IMAGES/EN_Codes.jpg" alt="">



                <!-- ################################################################################################ -->
                <h2 id="GRAY">Le code Gray</h2>
                <p>Le code de Gray est le code binaire r√©fl√©chi, c'est un cas tr√®s important des codes continus.</p>
                <p>Un code est continu au sens large si dans la table de v√©rit√© qui le d√©finit, les √©tats successifs
                    sont adjacents, c'est √† dire que quand on passe de l'un √† l'autre, il y a un seul chiffre qui
                    change. Un code est continu au sens strict si en plus le premier et le dernier √©tat sont adjacents.
                </p>
                <p>Un code r√©fl√©chi est un code naturel dont on a renvers√© le sens de variation par endroits afin de le
                    rendre continu. On renverse une p√©riode sur deux en commen√ßant par la deuxi√®me. Le tableau
                    ci-dessous illustre le code ternaire (base 3) r√©fl√©chi.</p>
                <img src="IMAGES/EN_TernaireReflechi.jpg" alt="">
                <p>Le tableau ci-dessous illustre le code Gray</p>
                <img src="IMAGES/EN_Gray.jpg" alt="">
                <p>Le code de Gray est tr√®s fr√©quemment utilis√© notamment sur les tables de Karnaugh pour simplifier les
                    fonctions
                    logiques. Remarquons que le code de Gray est continu au sens stricte, 0 est adjacent avec 15</p>
                <img src="IMAGES/EN_Karnaugh.jpg" alt="">
                <p>Comme on le voit sur la figure, la table de Karnaugh est une table de v√©rit√© repr√©sent√©e d'une fa√ßon
                    particuli√®re. Les adresses des cases sont repr√©sent√©es en code de Gray de sorte √† ce que toutes les
                    cases qui ont un cot√© commun soient adjacentes. Les cases sur les extr√©mit√©s oppos√©es sont aussi
                    adjacentes, on peut v√©rifier les adjacentes suivantes : 0-3, 7-4, 8-11, 15-12, 0-15, 1-14, 2-13,
                    3-12</p>
                <p>Si on consid√®re la table comme une feuille de papier, on peut v√©rifier les adjacence en enroulant la
                    feuille verticalement et horizontalement</p>
                <img src="IMAGES/EN_KarnaughAdj.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="BOOLE">Alg√®bre de Boole</h2>
                <p>L'alg√®bre de Boole est une branche des math√©matiques qui traite des variables logiques et des
                    op√©rations logiques. Elle a √©t√© d√©velopp√©e par George Boole au XIXe si√®cle et constitue la base des
                    syst√®mes num√©riques et de l'informatique moderne. C'est l'alg√®bre des variables qui ne peuvent
                    prendre que deux valeurs g√©n√©ralement not√©es 0 et 1, repr√©sentant le faux et le vrai. Les op√©rations
                    fondamentales de
                    l'alg√®bre de Boole incluent le ET (AND), le OU (OR), et le NON (NOT), qui permettent de manipuler
                    les valeurs logiques pour r√©soudre des probl√®mes de logique et de conception de circuits num√©riques.
                    Cette discipline est essentielle pour comprendre le fonctionnement des ordinateurs et des syst√®mes
                    √©lectroniques</p>

                <!-- ################################################################################################ -->
                <h2 id="VARLOGIC">Variables, Fonction et Op√©rateur logiques</h2>
                <p>L'alg√®bre de Boole repose sur :</p>
                <h3>Variables Bool√©enne</h3>
                <p>C'est une grandeur qui ne peut prendre que deux valeurs 0 ou 1</p>

                <!-- ################################################################################################ -->
                <h3 id="FONCLOGIC">Fonctions Bool√©enne</h3>
                <p>C'est une fonction de une ou plusieurs variables bool√©ennes, ne pouvant prendre elle-m√™me qu'une
                    des deux valeurs 0 ou 1. Pour la d√©finir, il faut pr√©ciser sa valeur pour toutes les
                    combinaisons possibles des variables.</p>
                <p>Il arrive que l'√©tat de la fonction ne soit d√©termin√© pour certaines combinaison des entr√©es. Dans ce
                    cas on met un 'x' dans la table de v√©rit√© pour indiquer que l'√©tat de la fonction dans ces cas n'a
                    pas d'importance et il peut √™tre consid√©r√© comme un '1' ou un '0'. Cela arrive quand certaines
                    combinaisons des entr√©es ne peuvent pas exister dans la pratique. Rien de mieux qu'un petit exemple
                    pour illustrer ce genre de situation :</p>
                <p>On d√©sire maintenir la temp√©rature d'une salle de travail entre 17¬∞C et 20¬∞C.
                    Nous nous procurons deux capteurs de temp√©rature ayant chacun une sortie logique que nous
                    appellerons C17 et C20 . Chaque capteur fonctionne de la mani√®re suivante</p>
                <ul>
                    <li>C17 = 0 si la temp√©rature est &lt; √† 17¬∞C , C17 = 1 si la temp√©rature est &gt; √† 17¬∞C</li>
                    <li>C20 = 0 si la temp√©rature est &lt; √† 20¬∞C , C20 = 1 si la temp√©rature est &gt; √† 20¬∞C</li>
                </ul>
                <p>On va essayer de construire un syst√®me logique qui d√©livre une alarme S chaque fois que la
                    temp√©rature sort de l'intervalle [17¬∞,20¬∞]. Ce qui revient √† chercher la fonction S des deux
                    variables C17 et C20 , S = f(C17 ,C20 )</p>
                <img src="IMAGES/EN_Simp_X.jpg" alt="">
                <p>La figure illustre les trois situations possibles de la temp√©rature, les √©tat des capteurs et la
                    valeur de la
                    fonction S.</p>
                <p>Quand on dresse la table de v√©rit√©, avec deux variables, on a quatre combinaison possibles :</p>
                <img src="IMAGES/EN_Simp_X_TV.jpg" alt="">
                <p>On s'aper√ßoit qu'il manque l'√©tat (C17=0, C20=1), normal, cet √©tat ne peu pas exister car il
                    correspond √† une temp√©rature en m√™me temps inf√©rieure √† 17 et sup√©rieure √† 20. Dans la table v√©rit√©
                    on met un x comme valeur de S ce qui signifie qu'on <i>s'en fout</i> de sa valeur puisque cet √©tat
                    est impossible. Lors de la recherche de l'expression de S, on peut consid√©rer le 'x' comme un 0 ou
                    comme un 1 selon la convenience</p>

                <!-- ########################################################## -->
                <h3 id="OPLOGIC">Op√©rateurs logiques</h3>
                <p>On peut montrer que toute fonction bool√©enne peut se synth√©tiser √† partir d'un nombre tr√®s
                    r√©duit de fonctions (√©l√©mentaires) de deux variables ou l'extension √† plusieurs variables de
                    ces m√™mes fonctions. Ces fonctions sont souvent appel√©es Op√©rateurs.</p>
                <ul>
                    <li>Op√©rateur <b>ET</b> (AND)
                        <img src="IMAGES/EN_AND.jpg" alt="">
                        <p class="InlineCenter">(A . B) est vrai si et seulement si A est vraie <b>et</b> B est
                            vraie</p>
                    </li>
                    <li>Op√©rateur <b>OU</b> (OR)
                        <img src="IMAGES/EN_OR.jpg" alt="">
                        <p class="InlineCenter">(A + B) est vrai si et seulement si A est vraie <b>ou</b> B est
                            vraie</p>
                    </li>
                    <li>Op√©rateur <b>NON</b> (NOT)
                        <img src="IMAGES/EN_NOT.jpg" alt="">
                        <p class="InlineCenter">Inverse la valeur de l'entr√©e</p>
                    </li>
                </ul><br>
                <p><b>Les trois op√©rateurs de base, AND, OR et NOT, suffisent √† construire n'importe quelle
                        fonction logique. Cependant, dans certaines situations, l'utilisation d'op√©rateurs
                        combin√©s
                        comme XOR, NAND et NOR peut √™tre avantageuse pour simplifier l'√©criture des fonctions et
                        faciliter la conception de syst√®mes √©lectroniques.</b></p><br>
                <ul><br>
                    <li>Op√©rateur <b>OU exclusif</b> (XOR)
                        <img src="IMAGES/EN_XOR.jpg" alt="">
                        <p class="InlineCenter">(A &oplus; B) est vrai si et seulement si A est vraie <b>ou</b>
                            B est
                            vraie mais pas les deux √† la fois</p>
                        <p>XOR est un op√©rateur combin√© car il peut √™tre construit √† l'aide des op√©rateurs de
                            base :</p>
                        <p>\( \rm A \oplus B = A\overline{B}+\overline{A}B \)</p>
                        <p><img src="IMAGES/EN_XOR_Comb.jpg" alt=""></p>
                    </li><br>
                    <li>Op√©rateur <b>NON ET</b> (NAND)
                        <img src="IMAGES/EN_NAND.jpg" alt="">
                        <p>C'est le compl√©ment de l'op√©rateur ET. C'est l'op√©rateur le plus couramment utilis√©
                            dans la pratique, on verra pourquoi quand on aura vu la r√®gle de Morgan</p>
                    </li><br>
                    <li>Op√©rateur <b>NON OU</b> (NOR)
                        <img src="IMAGES/EN_NOR.jpg" alt="">
                        <p>C'est le compl√©ment de l'op√©rateur OU.</p>
                    </li><br>
                </ul>


                <!-- ################################################################################################ -->
                <h2 id="IDENTREM"> Identit√©s remarquables</h2>
                <h3>√âl√©ment neutre, √©l√©ment absorbant et compl√©mentarit√© :</h3>
                <p class="InlineCenter">
                    \( \boxed{
                    \begin{matrix}
                    \rm{A} &+ &0 &= &\rm{A} \\
                    \rm{A} &+ &1 &= &1 \\
                    \rm{A} &+ &\bar{\rm{A}} &= &1
                    \end{matrix}}
                    \)
                    &nbsp;&nbsp;&nbsp;
                    \( \boxed{
                    \begin{matrix}
                    \rm{A} &. &0 &= &0 \\
                    \rm{A} &. &1 &= &\rm{A} \\
                    \rm{A} &. &\bar{\rm{A}} &= &0
                    \end{matrix} }
                    \)
                </p><br>

                <h3>Idempotence :</h3>
                $$
                \boxed{
                \begin{matrix}
                \rm{A} &+ &\rm{A} &= &\rm{A} \\
                \rm{A} &. &\rm{A} &= &\rm{A}
                \end{matrix}
                }
                $$

                <h3>Commutativit√© :</h3>
                $$
                \boxed{
                \begin{array}{c}
                {A+B=B+A}\\
                {A\;.\;B=B\;.\;A}
                \end{array}
                }
                $$

                <h3>Associativit√© :</h3>
                $$ \boxed{ \begin{array}{c}{(A+B)+C=A+(B+C)}\\{(A \;.\; B)\;.\;C=A\;.\;(B\;.\;C)}\\\end{array} }$$

                <h3>Absorption :</h3>
                $$ \boxed{A.(A+B)= A} $$
                En effet : \(A.(A+B)=AA+AB=A+AB=A.(1+B)=A\)

                <h3>Distributivit√©</h3>
                <p>‚Ä¢ est distributive par rapport √† + <br>
                    + est distributive par rapport √† ‚Ä¢</p>

                $$ \boxed{ \begin{matrix}
                \rm{A.(B+C)=AB+AC} \\
                \rm{A+B.C=(A+B).(A+C)}
                \end{matrix} }
                $$
                <p>Verification : <br>
                    \(
                    \begin{aligned}
                    \rm{(A+B).(A+C)}&=\rm{A.(A+C)+B.(A+C)}\\
                    &=\rm{A+BA+BC}\\
                    &=\rm{A.(1+B)+BC}\\
                    &=\rm{A+BC}
                    \end{aligned}
                    \)
                </p>

                <h3>Autres identit√©s :</h3>
                $$
                \boxed{
                \begin{matrix}
                \rm{A.B+A.\bar{B}=A} \\
                \rm{(A+B).(A+\bar{B})=A}
                \end{matrix}
                }
                $$
                <p>V√©rification: <br>
                    \( \rm{A.B+A.\bar{B}=A.(B+\bar{B})=A.1=A} \) <br>

                    \( \mathrm{(A+B).(A+\bar{B})=A+(B.\bar{B})=A+0=A} \)
                </p><br>

                $$ \boxed{ \mathrm{A+\bar{A}B=A+B} } $$
                <p>En effet : <br>
                    \( \rm{A+\bar{A}B=(A+\bar{A}).(A+B)=1.(A+B)=A+B} \)
                </p>


                <!-- ################################################################################################ -->
                <h2 id="MORGAN">Th√©or√®me de Morgan</h2>
                <p>Rappelons la table de v√©rit√© des op√©rateurs ET et OU :</p>
                <img src="IMAGES/EN_AND_OR_Tables.jpg" alt="">
                <p>On peut lire ces tables d'une fa√ßon diff√©rente de ce que nous avons l'habitude de faire :</p>
                <ul>
                    <li>A+B est fausse si et seulement si A et fausse et B est fausse,</li>
                    <li>A.B est fausse si et seulement si A et fausse ou B est fausse</li>
                </ul>
                <p>Ces deux phrases peuvent se traduire alg√©briquement par :</p>
                $$ \boxed{ \overline{\rm{A+B}}=\overline{\rm{A}} . \overline{\rm{B}}} $$
                $$ \boxed{ \overline{\rm{A.B}}=\overline{\rm{A}} + \overline{\rm{B}}} $$
                <p>On coupe la barre et on change l'op√©rateur</p><br>




                <!-- ################################################################################################ -->
                <h2 id="CANONIC">Forme Canonique</h2>
                <p>Soit la fonction S d√©finie par la table de v√©rit√© :</p>
                <img src="IMAGES/EN_Canonic.jpg" alt="">
                <p>Cette table de v√©rit√© peut s'√©crire de la fa√ßon alg√©brique suivante :</p>
                $$
                \rm{S(A, B, C)=A B \bar{C}+\bar{A} \bar{B} C+A \bar{B} C+\bar{A} B C+A B C}
                $$
                <p>A droite du signe =, on a une expression logique, c'est
                    un peut l'√©quivalent d'un polyn√¥me</p>
                <p>Cependant, Il y a d'autre expression diff√©rentes mais √©quivalentes pour repr√©senter la
                    fonction S. On peut v√©rifier sur la table qu'on a aussi \(S=B C+A B+A C+\bar{A} C\)</p>
                <p>La premi√®re expression de S est particuli√®re. Dans chaque
                    mon√¥me, figurent toutes les variables. Cette expression est appel√©e <em>forme canonique somme</em>.
                    C'est l'expression qui traduit fid√®lement la table de v√©rit√©. Ce n'est pas l'expression la plus
                    simple. Nous apprendrons plus tard √† la simplifier √† l'aide de la m√©thode de Karnaugh</p><br>
                <p><em>La forme canonique produit</em> revient √† √©crire l'expression de \(\bar{S}\) :</p>
                <p>\(\bar{S}(A, B, C)=\bar{A} \bar{B} \bar{C}+A \bar{B} \bar{C}+\bar{A} B \bar{C}\)</p>
                <p>On inverse tout :</p>
                <p>\( S(A,B,C)=\overline{ \bar{A}\bar{B}\bar{C}+A\bar{B}\bar{C}+\bar{A}B\bar{C} } \) </p>
                <p>On utilise le th√©or√®me de Morgan (deux fois) :</p>
                <p>\( S(A,B,C)=\overline{ \bar{A}\bar{B}\bar{C}} . \overline{A\bar{B}\bar{C}} .
                    \overline{\bar{A}B\bar{C} } \) </p>
                <p>\(S(A,B,C)=(A+B+C).(\bar{A}+B+C).(A+\bar{B}+C)\)</p>

                <!-- ################################################################################################ -->
                <h2 id="NANDUNIVERSEL">NAND : Op√©rateur universel</h2>
                <p>D'apr√®s la forme canonique, Nous pouvons exprimer toute fonction √† l'aide de 3 op√©rateurs, AND, OR
                    et NOR. Voyons comment on peut faire pour n'utiliser que l'op√©rateur NAND pour
                    exprimer ces fonctions</p>
                <p>Prenons un exemple simple : S = AB + CD, le sch√©ma est le suivant :</p>
                <img src="IMAGES/EN_NANDUNIV1.jpg" alt="">
                <p>Si on inverse deux fois l'expression le r√©sultat ne change pas :</p>
                <p> \( S = \overline{\overline{AB+CD}} \)</p>
                <p>On utilise le th√©or√®me de Morgan :</p>
                <p> \( S = \overline{\overline{AB}.\overline{CD}} \)</p>
                <p>Le sch√©ma correspondant est le suivant :</p>
                <img src="IMAGES/EN_NAND_Univ.jpg" alt="">
                <p>On s'aper√ßoit que ce r√©sultat peut √™tre obtenu en travaillant directement sur le sch√©ma en rempla√ßant
                    syst√©matiquement les op√©rateur AND et OR par des NAND</p>
                <p>Cette r√®gle ne s'applique que si la condition suivante est v√©rifi√©e :</p>
                <p><strong> En suivant n'importe quel chemin entre une entr√©e et une sortie, on rencontre
                        alternativement un AND et un OR. Le premier √©tant obligatoirement un AND et le dernier
                        obligatoirement un OR. <br>
                        Si cette condition n'est pas v√©rifi√©e, on peut y rem√©dier en intercalant
                        des op√©rateurs A.A ou A+A aux endroits ad√©quats. Ceux ci ne changent
                        rien au fonctionnement d'origine. On les appelle les op√©rateurs fant√¥mes</strong>
                </p>
                <p>Les fant√¥mes deviennent des NAND √† une entr√©e qui ne sont rien d'autre que des inverseurs</p>
                <img src="IMAGES/EN_NAND_fant_transform.jpg" alt="">
                <p>Exemple : Pour √™tre le plus g√©n√©ral possible, on va prendre une expression qui n'est pas sous
                    forme canonique :</p>
                <img src="IMAGES/EN_NAND_univ_Formule.jpg" alt="">
                <img src="IMAGES/EN_NAND_Univ_Ex.jpg" alt="">
                <p>La r√®gle n'est pas v√©rifi√©e, on ajoute les fant√¥mes</p>
                <img src="IMAGES/EN_NAND_UNIV_fant.jpg" alt="">
                <p>On remplace tout par des NAND</p>
                <img src="IMAGES/EN_NAND_Univ_Nand.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="SIMPFONC">Simplification des fonctions logiques</h2>
                <p>Il s'agit de chercher l'expression la plus simple d'une fonction bool√©enne. Ceci bien sur dans le but
                    d'avoir une r√©alisation avec un nombre minimum d'op√©rateurs.
                    Plusieurs m√©thodes existent, Nous allons parler de la m√©thode de Karnaugh (1953)
                </p>

                <h3 id="DKARNAUGH">Diagramme de Karnaugh</h3>
                <p>La table de Karnaugh est une table de v√©rit√© repr√©sent√©e d'une fa√ßon particuli√®re. Chaque case
                    correspond √† une ligne de la table de v√©rit√©. Les adresses des
                    cases sont repr√©sent√©es en code de Gray de sorte √† ce que toutes les cases qui ont un cot√© commun
                    soient adjacentes. Les cases sur les extr√©mit√©s oppos√©es sont aussi adjacentes car deux cases sont
                    adjacentes quand leurs adresses le sont.</p>
                <p>Voici un exemple pour 2, 3 puis 4 variables: </p>
                <img src="IMAGES/EN_Karnaugh234.jpg" alt="">

                <p>Sur la table ci-dessous, on peut v√©rifier les adjacentes suivantes : 0-3, 7-4, 8-11, 15-12, 0-15,
                    1-14, 2-13, 3-12. Si on
                    consid√®re la table comme une feuille de papier, on peut v√©rifier les adjacence d'extr√©mit√© en
                    enroulant la
                    feuille verticalement et horizontalement</p>
                <img src="IMAGES/EN_Karnaugh.jpg" alt="">
                <img src="IMAGES/EN_KarnaughAdj.jpg" alt="">

                <h3 id="REMPKAR">Remplissage de la table de Karnaugh</h3>
                <p>Il faut faire attention quand on remplit la table de Karnaugh √† partir de la table de v√©rit√©. La
                    correspondance
                    entre les lignes de la table de v√©rit√© et les cases de la table de Karnaugh d√©pend de la disposition
                    des variables
                    ABCD dans les cases adresses.</p>
                <p>Voici un exemple de table de v√©rit√© :</p>
                <img src="IMAGES/EN_Simp_Fonc_TVEx.jpg" alt="">
                <p>Voici des disposition possible de la table de Karnaugh</p>
                <img src="IMAGES/EN_SimpFonc_KarEx.jpg" alt="">
                <p>On obtient les tables suivantes pour la fonction de la table de v√©rit√©</p>
                <img src="IMAGES/EN_Simp_Fonc_K_Ex_Fonc.jpg" alt="">
                <p>Moi, j'utilise toujours la 2√®me disposition. Avec le temps, on acquiert un automatisme de
                    remplissage. üòä Enfin, c'√©tait il y a tr√®s longtemps. √áa fait des d√©cennies que je n'ai pas touch√© √†
                    √ßaüòä</p>

                <!-- ################################################################################################ -->
                <h2 id="GROUP">Regrouper les 1 en blocs</h2>
                <p>Maintenant on regroupe les '1' <b>Adjacents</b> en faisant des groupe de 1, 2, 4, 8 ...Ne pas oublier
                    les adjacences sur les extr√©mit√© de la table.</p>
                <p>Voici les r√®gles pour obtenir l'expression la plus simple :</p>
                <ul>
                    <li>Les blocs doivent √™tre constitu√©s de \(2^n\) cases contigu√´s (1, 2, 4, 8, ...).</li>
                    <li>Tous les 1 doivent √™tre entour√©s</li>
                    <li>Les 0 ne doivent pas √™tre entour√©s</li>
                    <li>Il faut faire les plus grands groupements possibles</li>
                    <li>Les x peuvent √™tre entour√© ou non selon le besoin</li>
                    <li>Les 1 et les x peuvent √™tre entour√© plusieurs fois</li>
                    <li>On s'arr√™te d√®s que tous les 1 sont entour√©s</li>
                </ul>
                <p>Voici quelques exemples :</p>
                <img src="IMAGES/EN_Simp_Groupes.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="LECTCARNAUGH">Lecture de la table de Karnaugh</h2>
                <p>Voir les exemples de la figure ci-dessus :</p>
                <ul>
                    <li><b>bloc contenant un seul '1' :</b> <br>
                        Le Minterme correspondant contient toutes les variables (sans simplification possible).</li>
                    <li><b>Un bloc contenant deux '1' :</b> <br>
                        Une seule variable change dans les deux cases du bloc. Cette variable est √©limin√©e dans le
                        Minterme correspondant.
                        Les variables qui ne changent pas sont conserv√©es</li>
                    <li><b>Un bloc contenant quatre '1' :</b> <br>
                        Deux variables changent dans les quatre cases du bloc (une variable horizontalement
                        et une verticalement). Ces deux variables sont √©limin√©es dans le Minterme.
                        Les variables qui restent constantes dans tout le bloc sont conserv√©es.</li>
                </ul>

                <!-- ################################################################################################ -->
                <h2 id="KEX1">Exemple 1: Binaire &xrarr; Gray</h2>
                <img src="IMAGES/EN_Simp_Bin_Gray.jpg" alt="">
                <p>Il y a quatre sortie, on cherche 4 fonctions : \( G_o, \; G_1,\; G_2 \;et\; G_3\)</p>
                <img src="IMAGES/EN_Simp_Bin_Gray_TV.jpg" alt="">
                <img class="inline" src="IMAGES/EN_Simp_Bin_Gray_Go.jpg" alt="">
                <img class="inline" src="IMAGES/EN_Simp_Bin_Gray_G1.jpg" alt="">
                <img class="inline" src="IMAGES/EN_Simp_Bin_Gray_G2.jpg" alt="">
                <p>Pour G3, on n'a pas besoin de table Karnaugh. On peut voir sur la table de v√©rit√© que :</p>
                <p>\(G_3=D\)</p>
                <img src="IMAGES/EN_Simp_Bin_Gray_Sch.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="KEX2">Exemple 2: Etude d'un convoyeur</h2>
                <p>Pour transporter le sable d'une position A vers une position B, on utilise le syst√®me suivant :</p>
                <img src="IMAGES/EN_Simp_Ex2.jpg" alt="">
                <p>Un chariot peut se d√©placer sur un rail sous l'action d'un moteur √©lectrique M :</p>
                <p>M=0 &rarr; moteur √† l'arr√™t, M=1 &rarr; moteur en marche</p>
                <p>Le d√©placement du chariot se fait toujours dans le m√™me sens. Deux capteurs A et B permettent de
                    d√©terminer la position du chariot :</p>
                <p>A=1 &rarr; chariot en position A, A=0 &rarr; le chariot n'est pas en position A. Le capteur B
                    fonctionne de la m√™me fa√ßon que A.</p>
                <p>Un capteur P plac√© sur le chariot permet de savoir si le chariot est plein ou vide :</p>
                <p>P=1 &rarr; chariot plain, P=0 &rarr; chariot vide.</p>
                <p>Le chariot peut √™tre remplit √† l'aide d'une trappe de remplissage Tr :</p>
                <p>Tr=1 &rarr; trappe ouverte, Tr=0 &rarr; trappe ferm√©e. </p>
                <p>Le chariot peut √™tre vid√© √† l'aide d'une trappe de vidange Tv :</p>
                <p>Tv = 1 &rarr; trappe ouverte, Tv = 0 &rarr; trappe ferm√©e</p>
                <p>Le fonctionnement se fait de la mani√®re suivante :</p>
                <p>Le chariot vide arrive en A (A=1, P=0), le moteur M s'arr√™te, la trappe de remplissage Tr s'ouvre, Un
                    fois le chariot plein, Tr se ferme et le chariot d√©marre. Quand le chariot arrive en B, il sarrette
                    et la trappe Tv s'ouvre. Quand le chariot est vide, la trappe Tv se ferme et le chariot d√©marre.
                    Quand il arrive en A le cycle recommence identique √† lui m√™me.</p>
                <p>Normalement, ce genre de syst√®me est √©tudi√© √† l'aide de m√©thode s√©quentielles. Vu sa simplicit√© nous
                    allons le faire avec un syst√®me combinatoire simple.</p>
                <p>Nous allons chercher les fonctions qui commandent les actionneurs M, Tr et Tv √† partir des entr√©e A,
                    B
                    et P</p>
                <img src="IMAGES/EN_Simp_Ex2_TV.jpg" alt="">
                <img src="IMAGES/EN_Simp_Ex2_K.jpg" alt="">
                <img src="IMAGES/EN_Simp_Ex2_Sch.jpg" alt="">






                <!-- ################################################################################################ -->
                <h2 id=""></h2>

                <br><br><br><br><br><br><br><br><br><br><br><br><br><br>



            </div>
        </div>
    </div>
</body>

</html>