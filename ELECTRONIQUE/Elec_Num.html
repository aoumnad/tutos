<!DOCTYPE html>
<html lang="fr-fr">

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="Abdelmajid OUMNAD" name="author">
    <meta content="Electronique Numérique" name="description">
    <meta content="Binaire, Hexadécimal, Porte logique, Bascule, JK, RS, Compteur, Multiplexeur, Additionneur"
        name="keywords">
    <title>Electronique Numérique</title>
    <link rel="icon" href="IMAGES/ElecLogo.png" type="image/png">
    <link rel="stylesheet" href="../styles.css">
    <script src="../scripts.js" defer></script>
    <script id="mathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
    <div class="TwoPanPageContainer">
        <div id="LeftPanel_ID" class="LeftPanel">
            <div class="LeftPanelHeader">
                <img src="../IMAGES/x3.png" id="XIcon" class="xicon Burger">
                <a href="../index.html"> <img src="../IMAGES/home48.png" alt=""> </a>
                <a href="Electronique.html"> <img src="IMAGES/ElecLogo.png" height="45px"> </a>
            </div>
            <div id="LeftPanelMenu_ID" class="LeftPanelMenu">

                <div class="rubrique" onclick="toggleMenu('numbers', this)">
                    <span>&gt;</span>
                    <h2>Representation des nombres</h2>
                </div>
                <div id="numbers" class="sub-rubrique">
                    <a href="#INTRO">
                        <h3>Systèmes pondérés</h3>
                    </a>
                    <a href="#BINARY">
                        <h3>Intérêt du système binaire</h3>
                    </a>
                    <a href="#CONVBASE">
                        <h3>Changement de base</h3>
                    </a>
                    <a href="#CALCBIN">
                        <h3>Calcul dans le système binaire</h3>
                    </a>
                    <a href="#REPNEG">
                        <h3>La représentation des nombres négatifs</h3>
                    </a>
                    <a href="#CODES">
                        <h3>Autres Representations</h3>
                    </a>
                    <a href="#GRAY">
                        <h3>Le code Gray</h3>
                    </a>


                </div>
                <div class="rubrique" onclick="toggleMenu('boole', this)">
                    <span>&gt;</span>
                    <h2>Algèbre de Boole</h2>
                </div>
                <div id="boole" class="sub-rubrique">
                    <a href="#BOOLE">
                        <h3>Introduction</h3>
                    </a>
                    <a href="#VARLOGIC">
                        <h3>Variables Booléenne</h3>
                    </a>
                    <a href="#FONCLOGIC">
                        <h3>Fonctions Booléenne</h3>
                    </a>
                    <a href="#OPLOGIC">
                        <h3>Opérateurs logiques</h3>
                    </a>
                    <a href="#IDENTREM">
                        <h3>Identités remarquables</h3>
                    </a>
                    <a href="#MORGAN">
                        <h3>Théorème de Morgan</h3>
                    </a>
                    <a href="#CANONIC">
                        <h3>Forme Canonique</h3>
                    </a>
                    <a href="#NANDUNIVERSEL">
                        <h3>NAND : Opérateur universel</h3>
                    </a>
                </div>

                <div class="rubrique" onclick="toggleMenu('simpfonc', this)">
                    <span>&gt;</span>
                    <h2>Simplification des fonctions logiques</h2>
                </div>
                <div id="simpfonc" class="sub-rubrique">
                    <a href="#SIMPFONC">
                        <h3>Introduction</h3>
                    </a>

                    <a href="#DKARNAUGH">
                        <h3>Diagramme de Karnaugh</h3>
                    </a>
                    <a href="#REMPKAR">
                        <h3>Remplissage de la table de Karnaugh</h3>
                    </a>
                    <a href="#GROUP">
                        <h3>Regrouper les 1 en blocs</h3>
                    </a>
                    <a href="#LECTCARNAUGH">
                        <h3>Lecture de la table de Karnaugh</h3>
                    </a>
                    <a href="#KEX1">
                        <h3>Exemple 1: Binaire &xrarr; Gray</h3>
                    </a>
                    <a href="#KEX2">
                        <h3>Exemple 2: Etude d'un convoyeur</h3>
                    </a>
                </div>
                <div class="rubrique" onclick="toggleMenu('circomb', this)">
                    <span>&gt;</span>
                    <h2>Circuits numérique combinatoires</h2>
                </div>
                <div id="circomb" class="sub-rubrique">
                    <a href="#CIRNUMCOMB">
                        <h2>Introduction</h2>
                    </a>
                    <div class="rubrique" onclick="toggleMenu('mxrsub', this)">
                        <span>&gt;</span>
                        <h2>Le multiplexeur</h2>
                    </div>
                    <div id="mxrsub" class="sub-rubrique">
                        <ul>
                            <li><a href="#MXR">
                                    <h3>Introduction</h3>
                                </a></li>
                            <li><a href="#MXR14">
                                    <h3>Multiplexeur 4:1</h3>
                                </a></li>
                            <li><a href="#MXREXT">
                                    <h3>Extension de Multiplexeurs</h3>
                                </a></li>
                            <li><a href="#MXRSFB">
                                    <h3>Synthèse de fonctions booléennes</h3>
                                </a></li>
                            <li><a href="#MXRDS">
                                    <h3>Choix d'un mot parmi Plusieurs</h3>
                                </a></li>
                            <li><a href="#MXRCMRCE">
                                    <h3>Multiplexeurs du commerce</h3>
                                </a></li>
                        </ul>
                    </div>
                    <a href="#DMXR">
                        <h2>Le démultiplexeur</h2>
                    </a>
                    <a href="#DCR">
                        <h2>Le décodeur</h2>
                    </a>
                    <a href="#DCRDMXR">
                        <h2>Décodeur/Démultiplexeur</h2>
                    </a>
                    <a href="#CMPRTR">
                        <h2>Comparateur</h2>
                    </a>

                    <div class="rubrique" onclick="toggleMenu('adder', this)">
                        <span>&gt;</span>
                        <h2>Additionneur</h2>
                    </div>
                    <div id="adder" class="sub-rubrique">
                        <a href="#ADDER">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#ADDER">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#HALFADDER">
                            <h3>Circuit Half adder</h3>
                        </a>
                        <a href="#FULLADDER">
                            <h3>Circuit Full adder</h3>
                        </a>
                        <a href="#ADDPR">
                            <h3>Additionneur à propagation de la retenue</h3>
                        </a>
                        <a href="#ADDUSAGE">
                            <h3>Utilisation correcte d'un additionneur</h3>
                        </a>
                        <a href="#U4BADDER">
                            <h3>Additionner 4 bits non signés</h3>
                        </a>
                        <a href="#S4BADDER">
                            <h3>Additionner 4 bits Signés</h3>
                        </a>
                        <a href="#SUBTOR">
                            <h3>Soustracteur</h3>
                        </a>
                        <a href="#ADDSUBTOR">
                            <h3>Additionneur/Soustracteur</h3>
                        </a>
                        <a href="#4BUADDSUB">
                            <h3>Additionneur/Soustracteur 4 bits Non signés</h3>
                        </a>
                        <a href="#4BSADDSUB">
                            <h3>Additionneur/Soustracteur 4 bits Signés</h3>
                        </a>
                    </div>
                    <div class="rubrique" onclick="toggleMenu('7seg', this)">
                        <span>&gt;</span>
                        <h2>Afficheurs 7 segments</h2>
                    </div>
                    <div id="7seg" class="sub-rubrique">
                        <a href="#7SEG">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#7SEGAC">
                            <h3>Anode Commune</h3>
                        </a>
                        <a href="#7SEGCC">
                            <h3>Cathode commune</h3>
                        </a>
                        <a href="#7SEG_DCR">
                            <h3>Décodeur BCD - 7 segments</h3>
                        </a>
                        <a href="#7SEG_PAC">
                            <h3>Pilotage Anode commune</h3>
                        </a>
                        <a href="#7SEG_PCC">
                            <h3>Pilotage Cathode commune</h3>
                        </a>
                        <a href="#BIN2BCD">
                            <h3>Binaire vers BCD</h3>
                        </a>
                        <a href="#7446-47-48">
                            <h3>Les circuits 7446, 7447 et 7448</h3>
                        </a>
                        <a href="#CD4511">
                            <h3>Le circuits CD4511</h3>
                        </a>
                    </div>
                </div>
                <div class="rubrique" onclick="toggleMenu('seq', this)">
                    <span>&gt;</span>
                    <h2>Circuits numériques séquentiels</h2>
                </div>
                <div id="seq" class="sub-rubrique">
                    <a href="#SEQINTRO">
                        <h3>Introduction</h3>
                    </a>
                    <div class="rubrique" onclick="toggleMenu('bascules', this)">
                        <span>&gt;</span>
                        <h2>Les bascules</h2>
                    </div>
                    <div id="bascules" class="sub-rubrique">
                        <a href="#CSBASE">
                            <h3>Le circuit de base</h3>
                        </a>
                        <a href="#CSRS">
                            <h3>La bascule RS</h3>
                        </a>
                        <a href="#CSRSH">
                            <h3>La bascule RSH</h3>
                        </a>
                        <a href="#CSJK">
                            <h3>La bascule JK</h3>
                        </a>
                        <a href="#CSJKH">
                            <h3>La bascule JKH</h3>
                        </a>
                        <a href="#CSFRONT">
                            <h3>Bascule Réagissant sur front d'horloge</h3>
                        </a>
                        <a href="#CSCONV">
                            <h3>Convention de dessin</h3>
                        </a>
                        <a href="#BASCULED">
                            <h3>La bascule D</h3>
                        </a>
                        <a href="#FRORÇAGE">
                            <h3>Entrées de forçage CLEAR et PRESET</h3>
                        </a>
                    </div>


                    <div class="rubrique" onclick="toggleMenu('registres', this)">
                        <span>&gt;</span>
                        <h2>Les Registres</h2>
                    </div>
                    <div id="registres" class="sub-rubrique">
                        <a href="#REGINTRO">
                            <h3>Chargement sur front</h3>
                        </a>
                        <a href="#REGLATCH">
                            <h3>Registre Latch</h3>
                        </a>
                        <a href="#REG273">
                            <h3>Le Registre 74LS273</h3>
                        </a>
                    </div>
                    <div class="rubrique" onclick="toggleMenu('shiftreg', this)">
                        <span>&gt;</span>
                        <h2>Les Registres à décalage</h2>
                    </div>
                    <div id="shiftreg" class="sub-rubrique">
                        <a href="#SHIFTREGI">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#PLOAD">
                            <h3>Chargement parallèle</h3>
                        </a>
                        <a href="#SYPLOAD">
                            <h3>Chargement parallèle Synchrone</h3>
                        </a>
                        <a href="#ASYPLOAD">
                            <h3>Chargement parallèle Asynchrone</h3>
                        </a>
                        <a href="#BIDSR">
                            <h3>Registre à décalage bidirectionnel</h3>
                        </a>
                        <a href="#SRUNIV">
                            <h3>Registre à décalage universel</h3>
                        </a>
                    </div>

                    <div class="rubrique" onclick="toggleMenu('ctrasync', this)">
                        <span>&gt;</span>
                        <h2>Les compteurs Asynchrones</h2>
                    </div>
                    <div id="ctrasync" class="sub-rubrique">
                        <a href="#ASYCTR">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#ASYDCTR">
                            <h3>Décompteur Asynchrone</h3>
                        </a>
                        <a href="#MODULON">
                            <h3>Comptage incomplet</h3>
                        </a>
                        <a href="#DIVFREQ">
                            <h3>Diviseur de fréquence</h3>
                        </a>
                        <a href="#CASCAASY">
                            <h3>Cascadage asynchrone</h3>
                        </a>
                        <a href="#CASCADBCD">
                            <h3>Compteur BCD</h3>
                        </a>
                        <a href="#74LS93">
                            <h3>Le compteur 74LS93</h3>
                        </a>
                        <a href="#74LS90">
                            <h3>Le compteur 74LS90</h3>
                        </a>
                        <a href="#BCD60">
                            <h3>Compteur BCD modulo 60</h3>
                        </a>
                        <a href="#BCD24">
                            <h3>Compteur BCD modulo 24</h3>
                        </a>
                    </div>
                    <div class="rubrique" onclick="toggleMenu('ctrsync', this)">
                        <span>&gt;</span>
                        <h2>Les compteurs Synchrones</h2>
                    </div>
                    <div id="ctrsync" class="sub-rubrique">
                        <a href="#SYNCTR">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#4BSYNCTR">
                            <h3>Compteur Synchrone 4 bits</h3>
                        </a>
                        <a href="#4BSYNCTRPL">
                            <h3>Version avec chargement parallèle</h3>
                        </a>
                        <a href="#4BSYNDCTR">
                            <h3>Décompteur Synchrone 4 bits</h3>
                        </a>
                        <a href="#CTRDCTRSYN">
                            <h3>Compteur/Décompteur Synchrone</h3>
                        </a>
                        <a href="#DECADESYNC">
                            <h3>Décade Synchrone</h3>
                        </a>
                        <a href="#CASCADSYNC">
                            <h3>Mise en cascade des compteurs synchrones</h3>
                        </a>
                        <a href="#CTRSYNBASCD">
                            <h3>Compteur synchrone avec des bascules D</h3>
                        </a>
                        <a href="#DCTRSYNDFF">
                            <h3>Décompteur synchrone avec des bascules D</h3>
                        </a>
                    </div>


                </div>
                <div class="rubrique" onclick="toggleMenu('realcircnum', this)">
                    <span>&gt;</span>
                    <h2>Technologie des circuits numériques</h2>
                </div>
                <div id="realcircnum" class="sub-rubrique">
                    <a href="#DIGITCIRCUIT">
                        <h3>Introduction</h3>
                    </a>
                    <div class="rubrique" onclick="toggleMenu('compocom', this)">
                        <span>&gt;</span>
                        <h2>Composants en commutation</h2>
                    </div>
                    <div id="compocom" class="sub-rubrique">
                        <a href="#COMTOR">
                            <h3>Le commutateur</h3>
                        </a>
                        <a href="#DIODCOMM">
                            <h3>La diode en commutation</h3>
                        </a>
                        <a href="#TRANSCOMM">
                            <h3>Le Transistor Bipolaire en commutation</h3>
                        </a>
                        <a href="#TRANSMOS">
                            <h3>Le Transistor MOS en commutation</h3>
                        </a>
                    </div>
                    <div class="rubrique" onclick="toggleMenu('famlogic', this)">
                        <span>&gt;</span>
                        <h2>Familles des circuits logiques</h2>
                    </div>
                    <div id="famlogic" class="sub-rubrique">
                        <a href="#FAMCIRLOGIC">
                            <h3>Introduction</h3>
                        </a>
                        <a href="#NAMING">
                            <h3>Nomenclature commerciale</h3>
                        </a>
                        <div class="rubrique" onclick="toggleMenu('famttl', this)">
                            <span>&gt;</span>
                            <h2>La famille TTL</h2>
                        </div>
                        <div id="famttl" class="sub-rubrique">
                            <a href="#TTLFMLY">
                                <h3>Introduction</h3>
                            </a>
                            <a href="#TTLCARC">
                                <h3>Caractéristiques principales :</h3>
                            </a>
                            <a href="#TTLSUBFAM">
                                <h3>Sous-familles courantes</h3>
                            </a>
                            <a href="#7400">
                                <h3>Le circuit 7400</h3>
                            </a>
                            <a href="#CARTRANS">
                                <h3>Caractéristique de transfert</h3>
                            </a>
                            <a href="#NIVLOGIC">
                                <h3>Niveaux logiques</h3>
                            </a>
                            <a href="#MARGEBRUIT">
                                <h3>Immunité au bruit</h3>
                            </a>
                            <a href="#IINPUTMAX">
                                <h3>Limites des Courants d'entrée</h3>
                            </a>
                            <a href="#IOUTUTMAX">
                                <h3>Limites des Courants de sortie</h3>
                            </a>
                            <a href="#SORTANCE">
                                <h3>Sortance</h3>
                            </a>
                            <a href="#PUISSANCE">
                                <h3>Puissance consommée</h3>
                            </a>
                            <a href="#TP">
                                <h3>Temps de propagation</h3>
                            </a>
                            <a href="#MAXFREQ">
                                <h3>Fréquence maximale d'utilisation</h3>
                            </a>
                            <a href="#OPENCOL">
                                <h3>Sortie collecteur ouvert</h3>
                            </a>
                            <a href="#TRISTATE">
                                <h3>Sortie trois états</h3>
                            </a>
                            <a href="#S_TRIG">
                                <h3>Entrées à trigger de Schmitt</h3>
                            </a>
                            <a href="#SUBFAM">
                                <h3>Spécifications de quelques Sous-familles TTL</h3>
                            </a>
                        </div>
                        <div class="rubrique" onclick="toggleMenu('famcmos', this)">
                            <span>&gt;</span>
                            <h2>La famille CMOS</h2>
                        </div>
                        <div id="famcmos" class="sub-rubrique">
                            <a href="#CMOS">
                                <h3>Introduction</h3>
                            </a>
                            <a href="#CD4000">
                                <h3>La série 4000</h3>
                            </a>
                            <a href="#4KINV">
                                <h3>Le circuit élémentaire (Inverseur)</h3>
                            </a>
                            <a href="#4KNIVLINP">
                                <h3>Niveaux logique en entrée</h3>
                            </a>
                            <a href="#4KNIVLOUT">
                                <h3>Niveaux logique en Sortie</h3>
                            </a>
                            <a href="#NOISEMARGIN">
                                <h3>Marge de bruit</h3>
                            </a>
                            <a href="#SORTANCE4K">
                                <h3>Sortance</h3>
                            </a>
                            <a href="#TPROP">
                                <h3>Temps de propagation</h3>
                            </a>
                            <a href="#CONSO">
                                <h3>Consommation</h3>
                            </a>
                            <a href="#74C">
                                <h3>Les circuits 74C</h3>
                            </a>
                            <a href="#NAND4011">
                                <h3>La porte NAND (4011)</h3>
                            </a>
                            <a href="#NOR4001">
                                <h3>La porte NOR (4001)</h3>
                            </a>
                        </div>
                    </div>
                    
                </div>
                <br><br><br>



            </div>
        </div>

        <!-- ################################################################################################ -->
        <div class="RightPanel">
            <div class="RightPanelHeader">
                <img onclick="montrerMenu()" class="Burger CursorPointer" src="../IMAGES/menu48.png">
                <h1>Electronique Numérique</h1>
            </div>
            <div class="RightPanelContent">



                <!-- ################################################################################################ -->
                <h2 id="INTRO">Representation des nombres</h2>
                <p>La représentation naturelle que nous utilisons pour représenter des nombres est une
                    représentation
                    <b>pondérée</b>. Les systèmes <b>Décimal</b> de base <i>B=10</i>, <b>Octal</b> de base
                    <i>B=8</i>,
                    Hexadécimal de base <i>B=16</i> et <b>Binaire</b> de base <i>B=2</i> sont des systèmes pondérés
                </p>
                <p>un système pondéré de base B est caractérisé par :</p>
                <ul>
                    <li>Il faut B symboles qu'on appelle <b>chiffres</b> pour représenter un nombre dans une bas B.
                        Par
                        exemple :
                        <ul>
                            <li>Le système Décimal utilise dix chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</li>
                            <li>Le système Octal utilise 8 chiffres : 0, 1, 2, 3, 4, 5, 6, 7</li>
                            <li>Le système Hexadécimal utilise 16 chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C,
                                D,
                                E, F</li>
                            <li>Le système Binaire utilise 2 chiffres : 0, 1</li>
                        </ul>
                    </li>
                    <li>Chaque chiffre a un "poids" qui dépend de sa position dans le nombre </li>
                    <li>Chaque poids est une puissance de B</li>
                    <li>A gauche de la virgule (.décimal), on a les puissances positives de B. A droite on a les
                        puissances négatives</li>
                    <li>Le poids du chiffre de rang i est B fois celui du rang i-1 <br>
                        <img src="IMAGES/EN_Poids.jpg" alt="">
                    </li>
                    <li>Exemples :
                        <ul>
                            <li>Le nombre 472 en base 10 peut être décomposé comme suit : <br>
                                \( 472_{10}= 4 &times; 10^2 + 7 &times; 10^1 + 2 &times; 10^0 \)</li>
                            <li>Le nombre 345.25 en base 10 peut être décomposé comme suit : <br>
                                \( 345.25_{10}= 3 &times; 10^2 + 4 &times; 10^1 + 5 &times; 10^0 + 2 &times; 10^{-1}
                                + 5
                                &times; 10^{-2} \)</li>
                            <li>Le nombre binaire 1011 peut être converti en décimal comme suit : <br>
                                \( 1101_2 =1&times;2^3 + 1&times;2^2 +0&times;2^1
                                +1&times;2^0=1&times;8+1&times;4+0&times;2+1&times;1=8+4+0+1=13_{10} \)</li>
                            <li>Le nombre binaire 101.101 peut être converti en décimal comme suit : <br>
                                \( 101.101_2 =1&times;4 + 0&times;2 + 1&times;1 + 1&times;0.5 + 0&times;0.25 +
                                1&times;0.125 = 5.625_{10} \)</li>
                            <li>Le nombre hexadécimal 2F3 peut être converti en décimal comme suit : br</li>
                            \( \rm{2F3_{16}}= 2&times;16^2 +F&times;16^1 +3&times;16^0 =
                            2&times;256+15&times;16+3&times;1=755_{10} \)
                        </ul>

                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h2 id="BINARY">Intérêt du système binaire</h2>
                <p>Le système binaire revêt une importance fondamentale en électronique et en informatique,
                    principalement parce qu'il est aisément transposable en signaux électriques. En effet, les deux
                    états possibles du système binaire, représentés par les chiffres 0 et 1, peuvent être
                    matérialisés
                    de diverses manières techniques, permettant ainsi de simplifier la conception et la fabrication
                    des
                    circuits électroniques. Parmi ces méthodes, on peut citer :
                </p>
                <ul>
                    <li>Le passage ou non d'un courant électrique dans un composant** : un circuit peut être conçu
                        pour
                        détecter la présence (représentant "1") ou l'absence (représentant "0") d'un courant
                        électrique,
                        une approche couramment utilisée dans les circuits logiques</li>
                    <li>L'état d'un commutateur** : par exemple, un transistor ou un autre type de dispositif peut
                        agir
                        comme un interrupteur, qui est soit ouvert (représentant "0"), soit fermé (représentant
                        "1").
                        Cette caractéristique est essentielle pour le fonctionnement des circuits intégrés et des
                        microprocesseurs
                        modernes</li>
                    <li>La valeur d'une tension électrique** : une tension spécifique peut être attribuée à chaque
                        état
                        binaire. Par exemple, une tension de +5 volts peut correspondre à "1", tandis qu'une tension
                        de
                        0 volt peut correspondre à "0". Cette méthode est particulièrement répandue dans les
                        systèmes
                        numériques pour transmettre des informations de manière fiable</li>
                </ul>
                <p>Ces représentations permettent une mise en œuvre robuste et efficace des systèmes numériques, qui
                    forment la base des technologies modernes, des ordinateurs aux systèmes embarqués en passant par
                    les
                    télécommunications.</p><br>

                <!-- ################################################################################################ -->
                <h2 id="CONVBASE">Changement de base</h2>
                <p>La conversion entre les systèmes dont la base est une puissance de v2 est très facile. Le
                    conversion
                    de ou vers la base 10 demande un peu plus de travail</p>
                <h3>Hexadécimal &xrarr; binaire</h3>
                <p>chaque chiffre Hexadécimal est écrit sur 4 bits :</p>
                <p>8E97A<sub>16</sub> = 1000 1110 1001 0111 1010<sub>2</sub> </p>

                <h3>Octal &xrarr; binaire</h3>
                <p>chaque chiffre octal est est écrit sur 3 bits :</p>
                <p>657<sub>8</sub> = 110 101 111<sub>2</sub> </p>

                <h3>Binaire &xrarr; Hexadécimal</h3>
                <p>Le nombre binaire est découpé en blocs de 4 bits en commençant de la droite (LSB), ensuite chaque
                    bloc de 4 bits est représenté en hexadécimal</p>
                <p>11110111110011011<sub>2</sub> = 1 1110 1111 1001 1011<sub>2</sub> = 1EF9B<sub>16</sub> </p>

                <h3>Decimal &xrarr; Binaire</h3>
                <p>La méthode la plus automatique et la division/multiplication en échelle.</p>
                <p>Pour la partie entière, on effectue une division successive par 2. On arrête quand on a un
                    quotient
                    nul. Le résultat en binaire est constitué par les restes successifs des divisions.
                </p>
                <p>Pour la partie décimale, on procède à des multiplications successives par 2. Le processus
                    s'arrête
                    dès qu'un produit entier est obtenu. Toutefois, il peut arriver que l'on n'obtienne jamais de
                    produit entier, dans ce cas, la multiplication peut théoriquement se poursuivre indéfiniment.
                    Dans une telle situation, on peut choisir de s'arrêter dès que l'on estime que le nombre de
                    chiffres
                    après la virgule est suffisant.</p>
                <h4>Exemple :</h4>
                <p>On va convertir le nombre 947,6407 en binaire</p>
                <p>Pour la partie entière on obtient :</p>
                <img src="IMAGES/EN_DivEch.jpg" alt="">
                <p>Pour la partie décimale :</p>
                <img src="IMAGES/EN_MulEch.jpg" alt="">
                <p>le résultat final est : <b><i>947,6407=<span class="blue">1110110011</span>.<span
                                class="red">101001</span> </i></b></p>

                <p> </p>

                <!-- ################################################################################################ -->
                <h2 id="CALCBIN">Calcul dans le système binaire</h2>
                <p>Le calcul dans le système binaire se fait de la même façon que nous avons appris à le faire en
                    décimal dans la petite école.</p>
                <h3>Addition :</h3>
                <p>
                    0 + 0 = 0 <br>
                    0 + 1 = 1 <br>
                    1 + 0 = 1 <br>
                    1 + 1 = 0 et on retient 1
                </p>
                <img src="IMAGES/EN_AddBin.jpg" alt="">
                <p>On remarque dans l'exemple qu'à cause de la retenue du rang précédent, on est amené à ajouter 3
                    bits. On en déduit qu'un additionneur élémentaire doit additionner 3 bits et produire une somme
                    et
                    une retenue. Nous reviendrons plus en détail sur cet aspect dans la section consacrée aux
                    circuits
                    numériques.</p><br>

                <h3>Soustraction :</h3>
                <p>
                    0 - 0 = 0 <br>
                    0 - 1 = 1 après avoir emprunté 1 à la rangée de gauche<br>
                    1 - 0 = 1 <br>
                    1 - 1 = 0 <br>
                </p>
                <img src="IMAGES/EN_SubBin.jpg" alt="">
                <p>Avec la soustraction, même s'il arrive qu'on parle de retenue, en fait c'est un emprunt (Borrow
                    en
                    anglais). On
                    constate sur l'exemple qu'à chaque colone, on effectue une soustraction de 3 bites \((X - Y -
                    B_{in})\) et on produit un résultat \(S\) et un Borrow \(B_{out}\). Le
                    tableau ci-dessous répertorie toutes les possibilités </p>
                <img src="IMAGES/EN_Sub_Bin_Table.jpg" alt="">
                <p> Nous reviendrons plus en détail sur cet aspect dans la section consacrée aux circuits
                    numériques.</p><br>

                <h3>Multiplication :</h3>
                <p>Là aussi, on procède comme on le fait en base 10</p>
                <img src="IMAGES/EN_MulBin.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="REPNEG">La représentation des nombres négatifs</h2>

                <p>Il existe plusieurs façons de représenter les nombres négatifs en binaire.
                    La plus utilisée en informatique est la méthode du <em>complément à deux</em>. Cette technique
                    repose sur une
                    propriété fondamentale : le complément (-N) d'un nombre N est défini de manière à vérifier
                    l'égalité
                    suivante : \(N+(-N)=0\)</p>
                <p>Cependant, en binaire, cette méthode n'a de sens que si l'on travaille avec un nombre fixe de
                    bits,
                    ce qui correspond à la taille des registres ou des données manipulées par une machine.
                    Prenons l'exemple d'une machine qui utilise 4 bits pour représenter les nombres. Cette machine
                    peut
                    représenter uniquement les nombres compris entre 0000 (0 en base 10) et 1111 (15 en base 10).

                    Examinons quelques opérations :</p>
                <ul>
                    <li>Si l'on effectue l'addition 0101 (5) + 0011 (3), on obtient 1000 (8). Le résultat est
                        correct et
                        reste dans la plage représentable.</li>
                    <li>En revanche, si l'on effectue 0111 (7) + 1101 (13), on obtient 0100 (4). Pourquoi? Parce que
                        la
                        machine n'a pas de place pour le cinquième bit généré par l'opération, qui correspondrait à
                        16.
                        Ce dépassement est appelé un débordement.</li>
                </ul>
                <p>Ce comportement implique qu'une machine 4 bits effectue ses calculs modulo \(2^4=16\).
                    Dans ce système, <b>le nombre 16 est équivalent à 0</b>. Par conséquent, la méthode du
                    complément à
                    deux repose sur la relation :
                    $$N+(-N)=16$$
                    Le complément du nombre N est donc :
                    $$(-N)=16-N$$
                    D'une façon générale, dans une machine n bits, le complément d'un nombre N est donné par :
                    $$(-N)=2^n-N$$
                </p>
                <p>Cette définition garantit que l'addition de N et de son complément donne toujours zéro</p>
                <p>Le complément à 2 d'un nombre peut être déterminé directement en binaire sans passer par les
                    relations ci-dessus.</p>
                <p>En effet :</p>
                $$(-N)=16-N=(15+1)-N=(15-N)+1$$
                <p>L'opération \(15-N\) s'appelle <em>le complément à 1</em> du nombre N. Elle revient à
                    complémenter un
                    par
                    un tous les bits du nombre N. Ensuite, il suffit d'ajouter 1 pour obtenir Le <em>Le complément à
                        2</em></p>

                <h4>Exemple :</h4>
                <p>Cherchons la représentation du nombre (-7) :</p>
                <ul>
                    <li> 7 = 0111</li>
                    <li>On inverse tous les bits &xrarr; 1000</li>
                    <li> On ajoute 1 &xrarr; -7 = 1001</li>
                    <li>vérification (7) + (-7) :
                        <img class="inline" src="IMAGES/EN_C2Verif.jpg" alt="">
                    </li>
                </ul><br>
                <p>En définitif, notre machine 4 bits peut représenter \(2^4=16\) nombres différents : </p>
                <ul>
                    <li>Soit non signés (tous positifs)
                        <img src="IMAGES/EN_Unsigned.jpg" alt="">
                    </li>
                    <li>Soit signés, 8 positifs et 8 négatifs :
                        <img src="IMAGES/EN_SignedTable.jpg" alt=""><br>
                        Remarquons que pour les nombres positifs, le MSB est égal à 0 et pour les nombres négatifs
                        le
                        MSB est
                        égal à 1. C'est ainsi que l'on peut tester si le résultat d'une opération est juste. Par
                        exemple,
                        pour l'addition, la règle est simple :
                        <ul>
                            <li>La somme de 2 nombres positifs doit donner un nombre positif</li>
                            <li>la somme de 2 nombres négatifs doit donner un nombre négatif</li>
                        </ul>
                        L'erreur se produit quand il y a débordement, c.a.d quand le résultat dépasse le nombre
                        maximum
                        que
                        la machine peut représenter soit +7 pour les nombres positifs ou -8 pour les nombres
                        négatifs.
                        Une
                        erreur peut se produire quand on ajoute des nombres de même signe. Il y a erreur quand le
                        signe
                        du
                        résultat est différent de celui des deux opérandes.
                        <img src="IMAGES/EN_SignedExmples.jpg" alt="">
                    </li>
                </ul><br>


                <h4>Généralisation :</h4>
                <div class="encadre">
                    <ul>
                        <li>Une machine \(n\) bits peut représenter \(2^n\) nombres différents :</li>
                        <li>Si on ne désire manipuler que des nombres positifs, on pourra représenter les nombres
                            allant
                            de \(0\) à \(2^n-1\) </li>
                        <li>Si on désire manipuler des nombres signés, on pourra représenter :
                            <ul>
                                <li>\(\frac{2^n}{2}\) Nombres positifs allant de \(\quad 0 \quad à \quad
                                    \left(\frac{2^n}{2}-1\right) \)</li>
                                <li>\(\frac{2^n}{2}\) Nombres négatifs allant de \(\quad -1 \quad à \quad
                                    -\frac{2^n}{2}
                                    \)</li>
                            </ul>
                        </li>
                    </ul>
                </div>




                <!-- ################################################################################################ -->
                <h2 id="CODES">Autres Representations</h2>
                <p>Le binaire naturel n'est pas la seule représentation des nombres utilisée en informatique.
                    Bien que le système binaire naturel (ou positionnel) soit largement employé pour représenter les
                    nombres en raison de sa simplicité et de son adéquation avec le fonctionnement des circuits
                    électroniques, d'autres systèmes de codage peuvent être mieux adaptés à certains contextes
                    spécifiques. Parmi ces systèmes, on trouve :</p>
                <ul>
                    <li><b>Le code BCD</b> (Binary-Coded Decimal) : Ce système représente chaque chiffre décimal
                        individuellement à
                        l'aide de 4 bits. Par exemple :
                        <ul>
                            <li>\( 457 = 111001001_{binaire} \)</li>
                            <li>\( 457 = 0100 \; 0101 \; 0111_{BCD} \)</li>
                        </ul>
                        Le code BCD est couramment utilisé dans les systèmes avec des afficheurs Sept segments
                        <img src="IMAGES/EN_7seg.jpg" alt="">
                    </li>
                    <li><b>Le code de Gray</b> : Utilisé principalement dans les systèmes de mesure et de contrôle.
                        Ce
                        code a la particularité de ne changer qu'un seul bit entre deux valeurs consécutives. Cela
                        le
                        rend particulièrement adapté aux dispositifs où des erreurs dues à des transitions multiples
                        de
                        bits
                        pourraient survenir, comme dans les codeurs rotatifs ou les circuits numériques synchrone.
                        Il
                        est aussi utilisé dans les tables de Karnaugh pour la simplification des fonctions logiques
                    </li>
                    <li>Le code excès-N (Excess-N) : Utilisé pour représenter des nombres signés ou non signés. Il
                        est
                        courant dans certains formats d'images numériques ou d'intervalles définis.

                    </li>
                </ul>
                <p>Ces systèmes de codage, bien que moins universels que le binaire naturel, répondent à des
                    besoins spécifiques en optimisant certains aspects comme la lisibilité humaine (BCD), la
                    robustesse
                    contre les erreurs (code de Gray) ou la gestion de plages numériques particulières (excès-N).
                    Ainsi,
                    le choix d'un système dépend largement des contraintes et des exigences de l'application
                    envisagée
                </p>
                <p>Le tableau ci-dessous présente l'exemple de quelques codes :</p>
                <img src="IMAGES/EN_Codes.jpg" alt="">



                <!-- ################################################################################################ -->
                <h2 id="GRAY">Le code Gray</h2>
                <p>Le code de Gray est le code binaire réfléchi, c'est un cas très important des codes continus.</p>
                <p>Un code est continu au sens large si dans la table de vérité qui le définit, les états successifs
                    sont adjacents, c'est à dire que quand on passe de l'un à l'autre, il y a un seul chiffre qui
                    change. Un code est continu au sens strict si en plus le premier et le dernier état sont
                    adjacents.
                </p>
                <p>Un code réfléchi est un code naturel dont on a renversé le sens de variation par endroits afin de
                    le
                    rendre continu. On renverse une période sur deux en commençant par la deuxième. Le tableau
                    ci-dessous illustre le code ternaire (base 3) réfléchi.</p>
                <img src="IMAGES/EN_TernaireReflechi.jpg" alt="">
                <p>Le tableau ci-dessous illustre le code Gray</p>
                <img src="IMAGES/EN_Gray.jpg" alt="">
                <p>Le code de Gray est très fréquemment utilisé notamment sur les tables de Karnaugh pour simplifier
                    les
                    fonctions
                    logiques. Remarquons que le code de Gray est continu au sens stricte, 0 est adjacent avec 15</p>
                <img src="IMAGES/EN_Karnaugh.jpg" alt="">
                <p>Comme on le voit sur la figure, la table de Karnaugh est une table de vérité représentée d'une
                    façon
                    particulière. Les adresses des cases sont représentées en code de Gray de sorte à ce que toutes
                    les
                    cases qui ont un coté commun soient adjacentes. Les cases sur les extrémités opposées sont aussi
                    adjacentes, on peut vérifier les adjacentes suivantes : 0-3, 7-4, 8-11, 15-12, 0-15, 1-14, 2-13,
                    3-12</p>
                <p>Si on considère la table comme une feuille de papier, on peut vérifier les adjacence en enroulant
                    la
                    feuille verticalement et horizontalement</p>
                <img src="IMAGES/EN_KarnaughAdj.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="BOOLE">Algèbre de Boole</h2>
                <p>L'algèbre de Boole est une branche des mathématiques qui traite des variables logiques et des
                    opérations logiques. Elle a été développée par George Boole au XIXe siècle et constitue la base
                    des
                    systèmes numériques et de l'informatique moderne. C'est l'algèbre des variables qui ne peuvent
                    prendre que deux valeurs généralement notées 0 et 1, représentant le faux et le vrai. Les
                    opérations
                    fondamentales de
                    l'algèbre de Boole incluent le ET (AND), le OU (OR), et le NON (NOT), qui permettent de
                    manipuler
                    les valeurs logiques pour résoudre des problèmes de logique et de conception de circuits
                    numériques.
                    Cette discipline est essentielle pour comprendre le fonctionnement des ordinateurs et des
                    systèmes
                    électroniques</p>

                <!-- ################################################################################################ -->
                <h2 id="VARLOGIC">Variables, Fonction et Opérateur logiques</h2>
                <p>L'algèbre de Boole repose sur :</p>
                <h3>Variables Booléenne</h3>
                <p>C'est une grandeur qui ne peut prendre que deux valeurs 0 ou 1</p>

                <!-- ################################################################################################ -->
                <h3 id="FONCLOGIC">Fonctions Booléenne</h3>
                <p>C'est une fonction de une ou plusieurs variables booléennes, ne pouvant prendre elle-même qu'une
                    des deux valeurs 0 ou 1. Pour la définir, il faut préciser sa valeur pour toutes les
                    combinaisons possibles des variables.</p>
                <p>Il arrive que l'état de la fonction ne soit déterminé pour certaines combinaison des entrées.
                    Dans ce
                    cas on met un 'x' dans la table de vérité pour indiquer que l'état de la fonction dans ces cas
                    n'a
                    pas d'importance et il peut être considéré comme un '1' ou un '0'. Cela arrive quand certaines
                    combinaisons des entrées ne peuvent pas exister dans la pratique. Rien de mieux qu'un petit
                    exemple
                    pour illustrer ce genre de situation :</p>
                <p>On désire maintenir la température d'une salle de travail entre 17°C et 20°C.
                    Nous nous procurons deux capteurs de température ayant chacun une sortie logique que nous
                    appellerons C17 et C20 . Chaque capteur fonctionne de la manière suivante</p>
                <ul>
                    <li>C17 = 0 si la température est &lt; à 17°C , C17 = 1 si la température est &gt; à 17°C</li>
                    <li>C20 = 0 si la température est &lt; à 20°C , C20 = 1 si la température est &gt; à 20°C</li>
                </ul>
                <p>On va essayer de construire un système logique qui délivre une alarme S chaque fois que la
                    température sort de l'intervalle [17°,20°]. Ce qui revient à chercher la fonction S des deux
                    variables C17 et C20 , S = f(C17 ,C20 )</p>
                <img src="IMAGES/EN_Simp_X.jpg" alt="">
                <p>La figure illustre les trois situations possibles de la température, les état des capteurs et la
                    valeur de la
                    fonction S.</p>
                <p>Quand on dresse la table de vérité, avec deux variables, on a quatre combinaison possibles :</p>
                <img src="IMAGES/EN_Simp_X_TV.jpg" alt="">
                <p>On s'aperçoit qu'il manque l'état (C17=0, C20=1), normal, cet état ne peu pas exister car il
                    correspond à une température en même temps inférieure à 17 et supérieure à 20. Dans la table
                    vérité
                    on met un x comme valeur de S ce qui signifie qu'on <i>s'en fout</i> de sa valeur puisque cet
                    état
                    est impossible. Lors de la recherche de l'expression de S, on peut considérer le 'x' comme un 0
                    ou
                    comme un 1 selon la convenience</p>

                <!-- ########################################################## -->
                <h3 id="OPLOGIC">Opérateurs logiques</h3>
                <p>On peut montrer que toute fonction booléenne peut se synthétiser à partir d'un nombre très
                    réduit de fonctions (élémentaires) de deux variables ou l'extension à plusieurs variables de
                    ces mêmes fonctions. Ces fonctions sont souvent appelées Opérateurs.</p>
                <ul>
                    <li>Opérateur <b>ET</b> (AND)
                        <img src="IMAGES/EN_AND.jpg" alt="">
                        <p class="InlineCenter">(A . B) est vrai si et seulement si A est vraie <b>et</b> B est
                            vraie</p>
                    </li>
                    <li>Opérateur <b>OU</b> (OR)
                        <img src="IMAGES/EN_OR.jpg" alt="">
                        <p class="InlineCenter">(A + B) est vrai si et seulement si A est vraie <b>ou</b> B est
                            vraie</p>
                    </li>
                    <li>Opérateur <b>NON</b> (NOT)
                        <img src="IMAGES/EN_NOT.jpg" alt="">
                        <p class="InlineCenter">Inverse la valeur de l'entrée</p>
                    </li>
                </ul><br>
                <p><b>Les trois opérateurs de base, AND, OR et NOT, suffisent à construire n'importe quelle
                        fonction logique. Cependant, dans certaines situations, l'utilisation d'opérateurs
                        combinés
                        comme XOR, NAND et NOR peut être avantageuse pour simplifier l'écriture des fonctions et
                        faciliter la conception de systèmes électroniques.</b></p><br>
                <ul><br>
                    <li>Opérateur <b>OU exclusif</b> (XOR)
                        <img src="IMAGES/EN_XOR.jpg" alt="">
                        <p class="InlineCenter">(A &oplus; B) est vrai si et seulement si A est vraie <b>ou</b>
                            B est
                            vraie mais pas les deux à la fois</p>
                        <p>XOR est un opérateur combiné car il peut être construit à l'aide des opérateurs de
                            base :</p>
                        <p>\( \rm A \oplus B = A\overline{B}+\overline{A}B \)</p>
                        <p><img src="IMAGES/EN_XOR_Comb.jpg" alt=""></p>
                    </li><br>
                    <li>Opérateur <b>NON ET</b> (NAND)
                        <img src="IMAGES/EN_NAND.jpg" alt="">
                        <p>C'est le complément de l'opérateur ET. C'est l'opérateur le plus couramment utilisé
                            dans la pratique, on verra pourquoi quand on aura vu la règle de Morgan</p>
                    </li><br>
                    <li>Opérateur <b>NON OU</b> (NOR)
                        <img src="IMAGES/EN_NOR.jpg" alt="">
                        <p>C'est le complément de l'opérateur OU.</p>
                    </li><br>
                </ul>


                <!-- ################################################################################################ -->
                <h2 id="IDENTREM"> Identités remarquables</h2>
                <h3>Élément neutre, élément absorbant et complémentarité :</h3>
                <p class="InlineCenter">
                    \( \boxed{
                    \begin{matrix}
                    \rm{A} &+ &0 &= &\rm{A} \\
                    \rm{A} &+ &1 &= &1 \\
                    \rm{A} &+ &\bar{\rm{A}} &= &1
                    \end{matrix}}
                    \)
                    &nbsp;&nbsp;&nbsp;
                    \( \boxed{
                    \begin{matrix}
                    \rm{A} &. &0 &= &0 \\
                    \rm{A} &. &1 &= &\rm{A} \\
                    \rm{A} &. &\bar{\rm{A}} &= &0
                    \end{matrix} }
                    \)
                </p><br>

                <h3>Idempotence :</h3>
                $$
                \boxed{
                \begin{matrix}
                \rm{A} &+ &\rm{A} &= &\rm{A} \\
                \rm{A} &. &\rm{A} &= &\rm{A}
                \end{matrix}
                }
                $$

                <h3>Commutativité :</h3>
                $$
                \boxed{
                \begin{array}{c}
                {A+B=B+A}\\
                {A\;.\;B=B\;.\;A}
                \end{array}
                }
                $$

                <h3>Associativité :</h3>
                $$ \boxed{ \begin{array}{c}{(A+B)+C=A+(B+C)}\\{(A \;.\; B)\;.\;C=A\;.\;(B\;.\;C)}\\\end{array} }$$

                <h3>Absorption :</h3>
                $$ \boxed{A.(A+B)= A} $$
                En effet : \(A.(A+B)=AA+AB=A+AB=A.(1+B)=A\)

                <h3>Distributivité</h3>
                <p>• est distributive par rapport à + <br>
                    + est distributive par rapport à •</p>

                $$ \boxed{ \begin{matrix}
                \rm{A.(B+C)=AB+AC} \\
                \rm{A+(B.C)=(A+B).(A+C)}
                \end{matrix} }
                $$
                <p>Verification : <br>
                    \(
                    \begin{aligned}
                    \rm{(A+B).(A+C)}&=\rm{A.(A+C)+B.(A+C)}\\
                    &=\rm{A+BA+BC}\\
                    &=\rm{A.(1+B)+BC}\\
                    &=\rm{A+BC}
                    \end{aligned}
                    \)
                </p>

                <h3>Autres identités :</h3>
                $$
                \boxed{
                \begin{matrix}
                \rm{A.B+A.\bar{B}=A} \\
                \rm{(A+B).(A+\bar{B})=A}
                \end{matrix}
                }
                $$
                <p>Vérification: <br>
                    \( \rm{A.B+A.\bar{B}=A.(B+\bar{B})=A.1=A} \) <br>

                    \( \mathrm{(A+B).(A+\bar{B})=A+(B.\bar{B})=A+0=A} \)
                </p><br>

                $$ \boxed{ \mathrm{A+\bar{A}B=A+B} } $$
                <p>En effet : <br>
                    \( \rm{A+\bar{A}B=(A+\bar{A}).(A+B)=1.(A+B)=A+B} \)
                </p>


                <!-- ################################################################################################ -->
                <h2 id="MORGAN">Théorème de Morgan</h2>
                <p>Rappelons la table de vérité des opérateurs ET et OU :</p>
                <img src="IMAGES/EN_AND_OR_Tables.jpg" alt="">
                <p>On peut lire ces tables d'une façon différente de ce que nous avons l'habitude de faire :</p>
                <ul>
                    <li>A+B est fausse si et seulement si A et fausse et B est fausse,</li>
                    <li>A.B est fausse si et seulement si A et fausse ou B est fausse</li>
                </ul>
                <p>Ces deux phrases peuvent se traduire algébriquement par :</p>
                $$ \boxed{ \overline{\rm{A+B}}=\overline{\rm{A}} . \overline{\rm{B}}} $$
                $$ \boxed{ \overline{\rm{A.B}}=\overline{\rm{A}} + \overline{\rm{B}}} $$
                <p><b>On coupe la barre et on change l'opérateur</b></p><br>




                <!-- ################################################################################################ -->
                <h2 id="CANONIC">Forme Canonique</h2>
                <p>Soit la fonction S définie par la table de vérité :</p>
                <img src="IMAGES/EN_Canonic.jpg" alt="">
                <p>Cette table de vérité peut s'écrire de la façon algébrique suivante :</p>
                $$
                \rm{S(A, B, C)=A B \bar{C}+\bar{A} \bar{B} C+A \bar{B} C+\bar{A} B C+A B C}
                $$
                <p>A droite du signe =, on a une expression logique, c'est
                    un peut l'équivalent d'un polynôme</p>
                <p>Cependant, Il y a d'autre expression différentes mais équivalentes pour représenter la
                    fonction S. On peut vérifier sur la table qu'on a aussi \(S=B C+A B+A C+\bar{A} C\)</p>
                <p>La première expression de S est particulière. Dans chaque
                    monôme, figurent toutes les variables. Cette expression est appelée <em>forme canonique
                        somme</em>.
                    C'est l'expression qui traduit fidèlement la table de vérité. Ce n'est pas l'expression la plus
                    simple. Nous apprendrons plus tard à la simplifier à l'aide de la méthode de Karnaugh</p><br>
                <p><em>La forme canonique produit</em> revient à écrire l'expression de \(\bar{S}\) :</p>
                <p>\(\bar{S}(A, B, C)=\bar{A} \bar{B} \bar{C}+A \bar{B} \bar{C}+\bar{A} B \bar{C}\)</p>
                <p>On inverse tout :</p>
                <p>\( S(A,B,C)=\overline{ \bar{A}\bar{B}\bar{C}+A\bar{B}\bar{C}+\bar{A}B\bar{C} } \) </p>
                <p>On utilise le théorème de Morgan (deux fois) :</p>
                <p>\( S(A,B,C)=\overline{ \bar{A}\bar{B}\bar{C}} . \overline{A\bar{B}\bar{C}} .
                    \overline{\bar{A}B\bar{C} } \) </p>
                <p>\(S(A,B,C)=(A+B+C).(\bar{A}+B+C).(A+\bar{B}+C)\)</p>

                <!-- ################################################################################################ -->
                <h2 id="NANDUNIVERSEL">NAND : Opérateur universel</h2>
                <p>D'après la forme canonique, Nous pouvons exprimer toute fonction à l'aide de 3 opérateurs, AND,
                    OR
                    et NOR. Voyons comment on peut faire pour n'utiliser que l'opérateur NAND pour
                    exprimer ces fonctions</p>
                <p>Prenons un exemple simple : S = AB + CD, le schéma est le suivant :</p>
                <img src="IMAGES/EN_NANDUNIV1.jpg" alt="">
                <p>Si on inverse deux fois l'expression le résultat ne change pas :</p>
                <p> \( S = \overline{\overline{AB+CD}} \)</p>
                <p>On utilise le théorème de Morgan :</p>
                <p> \( S = \overline{\overline{AB}.\overline{CD}} \)</p>
                <p>Le schéma correspondant est le suivant :</p>
                <img src="IMAGES/EN_NAND_Univ.jpg" alt="">
                <p>On s'aperçoit que ce résultat peut être obtenu en travaillant directement sur le schéma en
                    remplaçant
                    systématiquement les opérateur AND et OR par des NAND</p>
                <p>Cette règle ne s'applique que si la condition suivante est vérifiée :</p>
                <p><strong> En suivant n'importe quel chemin entre une entrée et une sortie, on rencontre
                        alternativement un AND et un OR. Le premier étant obligatoirement un AND et le dernier
                        obligatoirement un OR. <br>
                        Si cette condition n'est pas vérifiée, on peut y remédier en intercalant
                        des opérateurs A.A ou A+A aux endroits adéquats. Ceux ci ne changent
                        rien au fonctionnement d'origine. On les appelle les opérateurs fantômes</strong>
                </p>
                <p>Les fantômes deviennent des NAND à une entrée qui ne sont rien d'autre que des inverseurs</p>
                <img src="IMAGES/EN_NAND_fant_transform.jpg" alt="">
                <p>Exemple : Pour être le plus général possible, on va prendre une expression qui n'est pas sous
                    forme canonique :</p>
                <img src="IMAGES/EN_NAND_univ_Formule.jpg" alt="">
                <img src="IMAGES/EN_NAND_Univ_Ex.jpg" alt="">
                <p>La règle n'est pas vérifiée, on ajoute les fantômes</p>
                <img src="IMAGES/EN_NAND_UNIV_fant.jpg" alt="">
                <p>On remplace tout par des NAND</p>
                <img src="IMAGES/EN_NAND_Univ_Nand.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="SIMPFONC">Simplification des fonctions logiques</h2>
                <p>Il s'agit de chercher l'expression la plus simple d'une fonction booléenne. Ceci bien sur dans le
                    but
                    d'avoir une réalisation avec un nombre minimum d'opérateurs.
                    Plusieurs méthodes existent, Nous allons parler de la méthode de Karnaugh (1953)
                </p>

                <h3 id="DKARNAUGH">Diagramme de Karnaugh</h3>
                <p>La table de Karnaugh est une table de vérité représentée d'une façon particulière. Chaque case
                    correspond à une ligne de la table de vérité. Les adresses des
                    cases sont représentées en code de Gray de sorte à ce que toutes les cases qui ont un coté
                    commun
                    soient adjacentes. Les cases sur les extrémités opposées sont aussi adjacentes car deux cases
                    sont
                    adjacentes quand leurs adresses le sont.</p>
                <p>Voici un exemple pour 2, 3 puis 4 variables: </p>
                <img src="IMAGES/EN_Karnaugh234.jpg" alt="">

                <p>Sur la table ci-dessous, on peut vérifier les adjacentes suivantes : 0-3, 7-4, 8-11, 15-12, 0-15,
                    1-14, 2-13, 3-12. Si on
                    considère la table comme une feuille de papier, on peut vérifier les adjacence d'extrémité en
                    enroulant la
                    feuille verticalement et horizontalement</p>
                <img src="IMAGES/EN_Karnaugh.jpg" alt="">
                <img src="IMAGES/EN_KarnaughAdj.jpg" alt="">

                <h3 id="REMPKAR">Remplissage de la table de Karnaugh</h3>
                <p>Il faut faire attention quand on remplit la table de Karnaugh à partir de la table de vérité. La
                    correspondance
                    entre les lignes de la table de vérité et les cases de la table de Karnaugh dépend de la
                    disposition
                    des variables
                    ABCD dans les cases adresses.</p>
                <p>Voici un exemple de table de vérité :</p>
                <img src="IMAGES/EN_Simp_Fonc_TVEx.jpg" alt="">
                <p>Voici des disposition possible de la table de Karnaugh</p>
                <img src="IMAGES/EN_SimpFonc_KarEx.jpg" alt="">
                <p>On obtient les tables suivantes pour la fonction de la table de vérité</p>
                <img src="IMAGES/EN_Simp_Fonc_K_Ex_Fonc.jpg" alt="">
                <p>Moi, j'utilise toujours la 2ème disposition. Avec le temps, on acquiert un automatisme de
                    remplissage. 😊 Enfin, c'était il y a très longtemps. Ça fait des décennies que je n'ai pas
                    touché à
                    ça😊</p>

                <!-- ################################################################################################ -->
                <h2 id="GROUP">Regrouper les 1 en blocs</h2>
                <p>Maintenant on regroupe les '1' <b>Adjacents</b> en faisant des groupe de 1, 2, 4, 8 ...Ne pas
                    oublier
                    les adjacences sur les extrémité de la table.</p>
                <p>Voici les règles pour obtenir l'expression la plus simple :</p>
                <ul>
                    <li>Les blocs doivent être constitués de \(2^n\) cases contiguës (1, 2, 4, 8, ...).</li>
                    <li>Tous les 1 doivent être entourés</li>
                    <li>Les 0 ne doivent pas être entourés</li>
                    <li>Il faut faire les plus grands groupements possibles</li>
                    <li>Les x peuvent être entouré ou non selon le besoin</li>
                    <li>Les 1 et les x peuvent être entouré plusieurs fois</li>
                    <li>On s'arrête dès que tous les 1 sont entourés</li>
                </ul>
                <p>Voici quelques exemples :</p>
                <img src="IMAGES/EN_Simp_Groupes.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="LECTCARNAUGH">Lecture de la table de Karnaugh</h2>
                <p>Voir les exemples de la figure ci-dessus :</p>
                <ul>
                    <li><b>bloc contenant un seul '1' :</b> <br>
                        Le Minterme correspondant contient toutes les variables (sans simplification possible).</li>
                    <li><b>Un bloc contenant deux '1' :</b> <br>
                        Une seule variable change dans les deux cases du bloc. Cette variable est éliminée dans le
                        Minterme correspondant.
                        Les variables qui ne changent pas sont conservées</li>
                    <li><b>Un bloc contenant quatre '1' :</b> <br>
                        Deux variables changent dans les quatre cases du bloc (une variable horizontalement
                        et une verticalement). Ces deux variables sont éliminées dans le Minterme.
                        Les variables qui restent constantes dans tout le bloc sont conservées.</li>
                </ul>

                <!-- ################################################################################################ -->
                <h2 id="KEX1">Exemple 1: Binaire &xrarr; Gray</h2>
                <img src="IMAGES/EN_Simp_Bin_Gray.jpg" alt="">
                <p>Il y a quatre sortie, on cherche 4 fonctions : \( G_o, \; G_1,\; G_2 \;et\; G_3\)</p>
                <img src="IMAGES/EN_Simp_Bin_Gray_TV.jpg" alt="">
                <img class="inline" src="IMAGES/EN_Simp_Bin_Gray_Go.jpg" alt="">
                <img class="inline" src="IMAGES/EN_Simp_Bin_Gray_G1.jpg" alt="">
                <img class="inline" src="IMAGES/EN_Simp_Bin_Gray_G2.jpg" alt="">
                <p>Pour G3, on n'a pas besoin de table Karnaugh. On peut voir sur la table de vérité que :</p>
                <p>\(G_3=D\)</p>
                <img src="IMAGES/EN_Simp_Bin_Gray_Sch.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="KEX2">Exemple 2: Etude d'un convoyeur</h2>
                <p>Pour transporter le sable d'une position A vers une position B, on utilise le système suivant :
                </p>
                <img src="IMAGES/EN_Simp_Ex2.jpg" alt="">
                <p>Un chariot peut se déplacer sur un rail sous l'action d'un moteur électrique M :</p>
                <p>M=0 &rarr; moteur à l'arrêt, M=1 &rarr; moteur en marche</p>
                <p>Le déplacement du chariot se fait toujours dans le même sens. Deux capteurs A et B permettent de
                    déterminer la position du chariot :</p>
                <p>A=1 &rarr; chariot en position A, A=0 &rarr; le chariot n'est pas en position A. Le capteur B
                    fonctionne de la même façon que A.</p>
                <p>Un capteur P placé sur le chariot permet de savoir si le chariot est plein ou vide :</p>
                <p>P=1 &rarr; chariot plain, P=0 &rarr; chariot vide.</p>
                <p>Le chariot peut être remplit à l'aide d'une trappe de remplissage Tr :</p>
                <p>Tr=1 &rarr; trappe ouverte, Tr=0 &rarr; trappe fermée. </p>
                <p>Le chariot peut être vidé à l'aide d'une trappe de vidange Tv :</p>
                <p>Tv = 1 &rarr; trappe ouverte, Tv = 0 &rarr; trappe fermée</p>
                <p>Le fonctionnement se fait de la manière suivante :</p>
                <p>Le chariot vide arrive en A (A=1, P=0), le moteur M s'arrête, la trappe de remplissage Tr
                    s'ouvre, Un
                    fois le chariot plein, Tr se ferme et le chariot démarre. Quand le chariot arrive en B, il
                    sarrette
                    et la trappe Tv s'ouvre. Quand le chariot est vide, la trappe Tv se ferme et le chariot démarre.
                    Quand il arrive en A le cycle recommence identique à lui même.</p>
                <p>Normalement, ce genre de système est étudié à l'aide de méthode séquentielles. Vu sa simplicité
                    nous
                    allons le faire avec un système combinatoire simple.</p>
                <p>Nous allons chercher les fonctions qui commandent les actionneurs M, Tr et Tv à partir des entrée
                    A,
                    B
                    et P</p>
                <img src="IMAGES/EN_Simp_Ex2_TV.jpg" alt="">
                <img src="IMAGES/EN_Simp_Ex2_K.jpg" alt="">
                <img src="IMAGES/EN_Simp_Ex2_Sch.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id="CIRNUMCOMB">Circuits numérique combinatoires</h2>
                <p>Les circuits numériques forment la base des systèmes utilisés dans une variété
                    d'applications, allant des ordinateurs aux appareils électroniques embarqués.</p>
                <p>Contrairement aux circuits séquentiels qui
                    dépendent de l'état précédent pour produire une sortie, <b>les circuits combinatoires</b>
                    génèrent
                    une
                    sortie exclusivement en fonction de leurs entrées actuelles.</p>

                <p>Dans ce chapitre, nous allons explorer plusieurs types de circuits combinatoires couramment
                    utilisés
                    dans les systèmes numériques :</p>
                <ul>
                    <li><b>Les circuits d'aiguillage,</b> tels que les multiplexeurs et les démultiplexeurs, qui
                        permettent de
                        sélectionner ou de distribuer des signaux selon des critères spécifiques.</li>
                    <li><b>Les circuits arithmétiques,</b> comme les additionneurs et les soustracteurs, qui
                        exécutent
                        des
                        opérations mathématiques
                        essentielles au traitement numérique.</li>
                    <li><b>Les circuits d'identification,</b> tels que les comparateurs, qui permettent de comparer
                        des
                        données
                        numériques et de déterminer des relations entre elles.</li>
                    <li><b>Les systèmes d'affichage,</b> notamment les afficheurs à sept segments, qui traduisent
                        des
                        informations numériques en représentations visuelles compréhensibles.</li>
                </ul>

                <!-- ########################################################################### -->
                <h3 id="MXR">Le multiplexeur :</h3>
                <img src="IMAGES/EN_Mxr.jpg" alt="">
                <ul>
                    <li>Un multiplexeur a plusieurs entrées et une seule sortie,</li>
                    <li>Il permet de connecter la sortie à l'une des entrée conformément à l'adresse précisée par
                        les
                        entrées de sélection</li>
                    <li>Un multiplexeur à \(N\) entrées doit avoir \(n\) entrée de sélection tels que \(2^n \geq N\)
                    </li>

                </ul>
                <!-- ########################################################################### -->
                <h3 id="MXR14">Multiplexeur 1 parmi 4 :</h3>
                <img src="IMAGES/EN_Mxr14.jpg" alt="">
                <p>La table de vérité est :</p>
                <img src="IMAGES/EN_Mxr14_TV.jpg" alt="">
                <p>D'où l'expression logique de S</p>
                $$S=E_0\bar{A_0}\bar{A_1}+E_1\bar{A_0}A_1+E_2A_0\bar{A_1}+E_3A_0A_1$$
                <p>Ce qui donne le schéma :</p>
                <img src="IMAGES/EN_Mxr14_Sch.jpg" alt="">

                <!-- ########################################################################### -->
                <h3 id="MXREXT">Extension de Multiplexeurs :</h3>
                <p>Pour réaliser des multiplexeurs avec un grand nombre d'entrées, on peut utiliser de
                    petits multiplexeurs montés en <b>pyramide</b></p>
                <p>Par exemple, pour réaliser un multiplexeur 16:1, on peut utiliser 4 multiplexeurs 4:1</p>
                <img src="IMAGES/EN_Mxr16.jpg" alt="">
                <img src="IMAGES/EN_Mxr16_pyramide.jpg" alt="">
                <ul>
                    <li>Les bits d'adresse \(A_1A_0\) réalisent une première sélection. Les bits d'adresse
                        \(A_3A_2\)
                        finalisent la sélection</li>
                    <li>Les bits de faible poids de l'adresse doivent commander le premier étage,</li>
                    <li>J'ai représenté le multiplexeur de droite à gauche pour une meilleure représentation des
                        adresses sur le dessin (pour que le LSB \(A_o\) soit situé à droite)</li>
                </ul><br>

                <!-- ########################################################################### -->
                <h3 id="MXRSFB">Synthèse de fonctions booléennes :</h3>
                <p>Un multiplexeur peut être utilisé pour réaliser une fonction logique décrite par sa table de
                    vérité.
                    Cette technique est très utilisé dans les circuits logiques programmables (PLD) sous le nom de
                    LUT
                    <i>(Look Up Table)</i>
                </p>

                <h4>Méthode directe :</h4>
                <p>Ce n'est pas la méthode la plus économique, mais c'est la plus simple et la plus systématique</p>
                <img src="IMAGES/EN_Mxr_Synth.jpg" alt="">
                <ul>
                    <li>On établit la table de vérité de la fonction à réaliser,</li>
                    <li>Une fonction a \(n\) variables a une table de vérité de \(2^n\) lignes</li>
                    <li>Pour la réaliser on prend un multiplexeur avec \(n\) entrées de sélection, soit \(2^n\)
                        entrées
                        de données </li>
                    <li>On applique les entrées (variables) de la fonction aux entrées de sélection du multiplexeur
                    </li>
                    <li>On forces les entrée du multiplexeurs à \(0\) ou à \(1\) conformément à la table de vérité
                    </li>
                    <li>C'est tout, nous avons réalisé notre fonction😊</li>
                </ul><br>
                <b>Exemple :</b>
                <img src="IMAGES/EN_Mxr_Synth_ex1.jpg" alt=""><br>

                <h4>Méthode économique :</h4>
                <p>Moyennant un petit développement supplémentaire, on peut réaliser la même fonction logique avec
                    un
                    multiplexeur plus petit que la méthode directe. </p>
                <ul>
                    <li>Toute fonction logique de \(n\) variables est réalisable à l’aide d’un multiplexeur à
                        \(n-1\)
                        entrées de sélection</li>
                    <li>\(n-1\) variables de la fonction sont utilisées comme entrées de sélection du multiplexeur.
                        La
                        variable restante (Z) sera utilisée comme entrée du multiplexeur </li>
                    <li>Établir la table de vérité,</li>
                    <li>Décider que c'est la variable LSB qui servira de variable Z, les autres seront les variables
                        de
                        sélection</li>
                    <li>Regrouper les lignes de la table de vérité deux par deux. On obtient une table avec deux
                        fois
                        moins de lignes dont les variables sont les variable de sélection.</li>
                    <li>Définir les sortie de cette nouvelle table qui seront égale à \(0\), \(1\), \(Z\) ou à
                        \(\bar{Z}\)</li>
                    <li>Appliquer les sortie de la table Réduite aux entrées du multiplexeur</li>
                </ul><br>

                <b>Exemple : </b>
                <img src="IMAGES/EN_Mxr_Synth_ex2.jpg" alt=""><br>

                <b>Autre exemple :</b>
                <p>On désire réaliser un générateur de parité caractérisé par la fonction logique
                    \(F=\overline{A\oplus
                    B\oplus C}\)</p>
                <p>On établit la table de vérité à partir de la fonction logique et on procède comme indiqué
                    précédemment.</p>
                <img src="IMAGES/EN_Mxr_Synth_ex3.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="MXRDS">Choix d'un mot parmi Plusieurs</h3>
                <p>Il s'agit d'un multiplexeur plus élaboré qu'on appelle <b>sélecteur de donné</b>, (<i>Data
                        Selector</i> ) qui permet de choisir un mot de n bits parmi N mots tous de la même taille.
                    Là aussi on va utiliser des multiplexeurs classiques montés de façon adéquate.
                    La figure ci-dessous montre un sélecteur qui permet de choisir un mot parmi 4 mots de 8 bits</p>
                <img src="IMAGES/EN_Mxr_DS14.jpg" alt="">
                <p>La figure ci-dessous montre un sélecteur qui permet de choisir un mot parmi 8 mots de 4 bits</p>
                <img src="IMAGES/EN_Mxr_DS18.jpg" alt="">
                <p>Cette architecture est assez lourde et ne sera utilisée que si on n'a pas les moyen d'utiliser un
                    circuit PLD</p>

                <!-- ################################################################################################ -->
                <h3 id="MXRCMRCE">Multiplexeurs du commerce</h3>
                <p>On trouve dans le commerce beaucoup de multiplexeur différent. Nous en citeront deux à titre
                    d'exemple</p>
                <h4>Le 74LS151</h4>
                <p>Le 74 LS 151 est un multiplexeur en technologie bipolaire. Il permet de choisir une entrés parmi
                    8.
                    Il a
                    deux sorties, une sortie normale plus une sortie inversée. Il dispose aussi d'une entrée de
                    Validation E : E=0 &rarr; multiplexeur normal, E=1 &rarr; sortie = 0 &forall; l'état des entrées
                    et
                    des adresses
                </p>
                <img src="IMAGES/EN_Mxr_151.jpg" alt="">
                <p>L'entrée de validation peut être utilisée pour former un multiplexeur 16:1 sans l'utilisation de
                    la
                    structure en pyramide classique en utilisant une simple porte NAND à la place d'un multiplexeur
                    1/2
                </p>
                <img src="IMAGES/EN_Mxr_151_16.jpg" alt="">

                <h4>Le 74LS153</h4>
                <p>Le 74LS153 contient deux multiplexeurs 4:1 dans un seul boîtier. Chacun a sa propre entrée de
                    validation. Malheureusement, ils se partage les entrées de sélection, ils ne sont donc pas tout
                    à
                    fait indépendants.</p>
                <img src="IMAGES/EN_Mxr_153.jpg" alt="">
                <p>Voilà comment on peut l'utiliser pour réaliser un multiplexeur 8:1</p>
                <img src="IMAGES/EN_Mxr_153_18.jpg" alt=""><br><br>

                <h4>Autres multiplexeurs :</h4>
                <p>Dans la famille <b>TTL</b>, on peut citer : <br>
                    74LS151 : Multiplexeur 8 vers 1 (avec entrée d'activation).<br>
                    74LS153 : Double multiplexeur 4 vers 1 (deux MUX indépendants).<br>
                    74LS157 : Multiplexeur quadruple 2 vers 1 (quatre MUX indépendants de 2:1).<br>
                    74LS158 : Multiplexeur quadruple 2 vers 1 avec sorties actives bas.<br>
                    74LS150 : Multiplexeur 16 vers 1 (moins courant, utilisé pour des systèmes complexes).<br>
                    74LS148 : Priorité encodée pour applications avancées de multiplexage.<br><br>

                    Dans la famille <b>CMOS</b>, on peut citer : <br>
                    CD4051 : Multiplexeur analogique 8 vers 1 (également utilisé comme démultiplexeur).<br>
                    CD4052 : Multiplexeur analogique double 4 vers 1 (ou démultiplexeur).<br>
                    CD4053 : Multiplexeur analogique triple 2 vers 1.<br>
                    74HC151 : Multiplexeur 8 vers 1, CMOS rapide, équivalent au 74LS151.<br>
                    74HC153 : Double multiplexeur 4 vers 1, CMOS rapide, équivalent au 74LS153.<br>
                    74HC157 : Multiplexeur quadruple 2 vers 1, CMOS rapide, équivalent au 74LS157.<br>
                    74HC158 : Multiplexeur quadruple 2 vers 1 avec sorties actives bas.<br>
                    74HC4051 : Multiplexeur 8 vers 1 (signaux analogiques ou numériques).<br>
                    74HC4052 : Multiplexeur double 4 vers 1 (signaux analogiques ou numériques).<br>
                    CD4016/CD4066 : Commutateurs analogiques pouvant être configurés pour du multiplexage.<br>
                </p>

                <br><br><br>
                <!-- ################################################################################################ -->
                <h2 id="DMXR">Le démultiplexeur</h2>
                <p>Le démultiplexeur est le circuit complémentaire du multiplexeur. Il a <b>une entrée et plusieurs
                        sorties</b>
                    ainsi qu'un certain nombre d'entrées de sélection (d'adresse). </p>
                <p>La sortie "pointée" par l'adresse est connectée à l'entrée. Les autres sorties peuvent être soit
                    tous
                    à
                    l'état bas soit tous à l'état haut.</p>
                <img src="IMAGES/EN_Dmxr.jpg" alt=""><br>

                <h3>Démultiplexeur 1 parmi 4 (1:4)</h3>
                <p>On se propose de réaliser un démultiplexeur à 4 sorties S3, S2, S1, S0 , une entre E et deux bits
                    d'adresse A0, A1</p>
                <img src="IMAGES/EN_Dmxr_14.jpg" alt="">
                <h4>Démultiplexer 1:4 Type 1 : Sorties non sélectionnées = 0</h4>
                <img src="IMAGES/EN_Dmxr_14_TV.jpg" alt=""><br>
                <p>On a quatre sorties, il faut l'expression logique de chaque sortie :</p>
                <p>\(\rm{S_0=E \; \overline{A_1} \; \overline{A_0}} \)</p>
                <p>\(\rm{S_1 = E \; \overline{A_1} \; A_0 } \)</p>
                <p>\(\rm{S_2 = E \; A_1 \; \overline{A_0}} \)</p>
                <p>\(\rm{S_3 = E \; A_1 \; A_0 } \)</p>
                <img src="IMAGES/EN_Dmxr_14_Sch_Typ1.jpg" alt="">
                <h4>Démultiplexer 1:4 Type 2 : Sorties non sélectionnées = 1</h4>
                <p>Il suffit d'inverser toutes les sorties. La sortie sélectionnée sera aussi inversée se qui
                    donnera
                    \(\bar{E}\) au lieu de \(E\). On inverse aussi l'entrée et le tour est joué.</p>
                <img src="IMAGES/EN_Dmxr_14_Sch_Typ2.jpg" alt="">

                <!-- ################################################################################################ -->
                <h2 id="DCR">Le décodeur</h2>
                <p>Le décodeur est un démultiplexeur particulier. Il n'a pas d'entrée, la sortie sélectionné aura le
                    niveau logique inverse des autres sorties. Dès lors on peut distinguer deux types:</p>
                <p><strong>Type 1 :</strong></p>
                <ul>
                    <li>Sortie sélectionnée = 1</li>
                    <li>Sorties non sélectionnés = 0</li>
                </ul>
                <p><strong>Type 2 :</strong></p>
                <ul>
                    <li>Sortie sélectionnée = 0</li>
                    <li>Sorties non sélectionnés = 1</li>
                </ul>
                <h4>Décodeur 1:4 type 1</h4>
                <img src="IMAGES/EN_Dcr_14_Typ1.jpg" alt="">
                <h4>Décodeur 1:4 type 2</h4>
                <img src="IMAGES/EN_Dcr_14_Typ2.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id="DCRDMXR">Décodeur/Démultiplexeur</h2>
                <p>Vue leur très grande similarité, un démultiplexeur peut très bien être utilisé en décodeur</p>
                <h3>Décodeur/Démultiplexeur 1:4 type 1</h3>
                <img src="IMAGES/EN_Dmxr_14_Sch_Typ1.jpg" alt="">
                <ul>
                    <li><b>Mode démultiplexeur :</b>
                        <ul>
                            <li>E est l'entrée du démultiplexeur,</li>
                            <li>Sortie sélectionnée = E, les autres = 0
                            </li>
                        </ul>
                    </li>
                    <li><b>Mode décodeur :</b>
                        <ul>
                            <li>E sert d'entrée de validation,</li>
                            <li>E = 0 &rArr; circuit inhibé, toutes les sortie = 0 ∀ Ai </li>
                            <li>E = 1 &rArr; fonctionnement en décodeur : Sortie sélectionnée = 1, les autres = 0
                            </li>
                        </ul>
                    </li>
                </ul>
                <h3>Décodeur/Démultiplexeur 1:4 type 2</h3>
                <img src="IMAGES/EN_Dmxr_14_Sch_Typ2.jpg" alt="">
                <ul>
                    <li><b>Mode démultiplexeur :</b>
                        <ul>
                            <li>E est l'entrée du démultiplexeur,</li>
                            <li>Sortie sélectionnée = E, les autres = 1
                            </li>
                        </ul>
                    </li>
                    <li><b>Mode décodeur :</b>
                        <ul>
                            <li>E sert d'entrée de validation,</li>
                            <li>E = 1 &rArr; circuit inhibé, toutes les sortie = 1 ∀ Ai </li>
                            <li>E = 0 &rArr; fonctionnement en décodeur : Sortie sélectionnée = 0, les autres = 1
                            </li>
                        </ul>
                    </li>
                </ul><br>

                <h3>Décodeur/Démultiplexeur du commerce</h3>
                <h4>Le 74LS139</h4>
                <p>Contient deux décodeurs/démultiplexeurs 1:4 type 2</p>
                <img src="IMAGES/EN_DcrDmxr_139.jpg" alt="">
                <img src="IMAGES/EN_DcrDmxr_139_DIP.jpg" alt="">

                <h4>Le 74LS154</h4>
                <p>C'est un décodeurs/démultiplexeurs 1:16 type 2</p>

                <img src="IMAGES/EN_DcrDmxr_154.jpg" alt="">
                <img src="IMAGES/EN_DcrDmxr_154_DIP.jpg" alt="">
                <p>Les modes de fonctionnement sont résumé dans le tableau ci-dessous</p>
                <img src="IMAGES/EN_DcrDmxr_154_Fonc.jpg" alt=""><br>
                <h4>Autres décodeurs/démultiplexeurs</h4>
                <p> Dans la famille <b>TTL</b>, on peut citer : <br>
                    74LS138 : Décodeur 3 vers 8 avec une entrée d'activation. <br>
                    74LS139 : Double décodeur 2 vers 4 avec sorties actives bas.<br>
                    74LS154 : Décodeur 4 vers 16, utilisé pour le décodage d'adresses.<br>
                    74LS156 : Double décodeur 2 vers 4 avec sorties à collecteur ouvert.<br>
                    74LS155 : Double décodeur/démultiplexeur 2 vers 4 avec sorties actives bas.<br>
                    74LS151 : Démultiplexeur 1 vers 8 (multiplexeur 8 vers 1 en configuration inverse).<br>
                    74LS137 : Décodeur/démultiplexeur 3 vers 8 avec latch intégré pour les entrées.<br>
                    74LS145 : Décodeur BCD vers décimal, très utile pour les affichages numériques.<br><br>

                    Dans la famille <b>CMOS</b> on peut citer : <br>
                    CD4028 : Décodeur BCD vers décimal (4 vers 10).<br>
                    CD4514 : Décodeur 4 vers 16 avec latch intégré.<br>
                    CD4515 : Décodeur 4 vers 16 avec latch intégré et sorties actives bas.<br>
                    74HC138 : Décodeur 3 vers 8, CMOS rapide, similaire au 74LS138.<br>
                    74HC139 : Double décodeur 2 vers 4, CMOS rapide, similaire au 74LS139.<br>
                    74HC154 : Décodeur 4 vers 16, CMOS rapide, similaire au 74LS154.<br>
                    74HC145 : Décodeur BCD vers décimal avec sorties actives bas.<br>
                    74HC4051 : Démultiplexeur 1 vers 8 (également utilisé comme multiplexeur).<br>
                    CD4051 : Démultiplexeur/multiplexeur analogique 1 vers 8 (signal analogique ou numérique).<br>
                    CD4052 : Démultiplexeur/multiplexeur 2 vers 4 (signal analogique ou numérique).<br>
                </p>

                <!-- ################################################################################################ -->
                <h2 id="CMPRTR">Comparateur Numérique</h2>
                <img src="IMAGES/EN_Cmprtr.jpg" alt="">
                <p>Un comparateur Logique dit aussi circuit d'identification permet de tester l'égalité de deux
                    nombres.</p>
                <ul>
                    <li>A = B &rArr; S=1,</li>
                    <li>A &NotEqual; B &rArr; S=0,</li>
                </ul>
                <p>Deux nombres \( A=a_n...a_1a_o \) et \( B=b_n...b_1b_o \) sont égaux si tous les bits du même
                    poids
                    sont égaux : \( a_o=b_o\; et \; a_1=b_1\; et \; a_2=b_2 \; ... \)
                </p>
                <p>Étudions un circuit de comparaison entre deux bits :</p>
                <img src="IMAGES/EN_Cmprtr_2b_Tab.jpg" alt="">
                <p>\( S_i = \overline{a_i}~\overline{b_i}+a_i~b_i~=~\overline{a_i \oplus b_i} \)</p>
                <img src="IMAGES/EN_Cmprtr_2b_Sch.jpg" alt="">
                <p>On en déduit le schéma du comparateur de deux mots de n bits</p>
                <img src="IMAGES/EN_Cmprtr_nbits_Sch.jpg" alt=""><br>

                <h3>Comparateurs du commerce :</h3>
                <p>Le plus populaire et le 74LS85</p>
                <p>C'est un comparateur de deux mots de 4 bits</p>
                <p>Les entrées de mise en cascade \(I_{sup}, I_{eq} ~ et ~ I_{inf} \) servent à chaîner plusieurs
                    74LS85
                    et comparer des nombres plus grands.</p>
                <p>Voici l'essentiel du mode de fonctionnement. Voir la datasheet du circuit pour découvrir toutes
                    ses
                    possibilités</p>
                <p><b>Utilisation d'un comparateur seul :</b></p>
                <img src="IMAGES/EN_Cmprtr_85.jpg" alt=""><br>
                <p><b>Utilisation de plusieurs comparateurs en cascade :</b></p>
                <img src="IMAGES/EN_Cmprtr85_Cascd.jpg" alt=""><br>
                <p>Les sortie \(O_{sup}, O_{eq} ~ et ~ O_{inf} \) du comparateur seul ou du dernier se positionnent
                    comme suit :</p>
                <ul>
                    <li>\( A \gt B \Rightarrow ~ O_{sup}=1 ~,~ O_{eq}=0 ~,~O_{inf}=0 ~,~\)</li>
                    <li>\( A = B \Rightarrow ~ O_{sup}=0 ~,~ O_{eq}=1 ~,~O_{inf}=0 ~,~\)</li>
                    <li>\( A \lt B \Rightarrow ~ O_{sup}=0 ~,~ O_{eq}=0 ~,~O_{inf}=1 ~,~\)</li>
                </ul>

                <!-- ################################################################################################ -->
                <h2 id="ADDER">Additionneur Binaire</h2>
                <img src="IMAGES/EN_ADD_Bin.jpg" alt="">

                <p>Quand on additionne "manuellement" deux mots de \(n\) bits, on réalise \(n\) fois l'addition de
                    trois bits. Chaque addition génère une somme et une retenue. Ainsi, la conception d'un
                    additionneur
                    pour deux mots de \(n\) bits revient à assembler en cascade \(n\) additionneurs élémentaires de
                    trois bits.
                </p>
                <p>Pour faire l'étude d'un additionneur élémentaire 3 bits, on peut procéder de deux façons :</p>
                <ol>
                    <li>Faire comme on fait à la main. Additionner les bits deux par deux. On commence par
                        additionner
                        les deux premiers bits, ensuite on additionne le résultat avec le 3ème bits. La retenue
                        finale
                        est
                        celle produite par la première <b>ou</b> la deuxième addition. Cela reviendra à étudier un
                        circuit réalisant une addition deux bits, et d'en brancher deux en cascade pour réaliser
                        l'addition 3 bits. L'additionneur <b>deux bits</b> a été baptisé <em>Half adder</em>.
                        L'additionneur <b>trois bits</b>
                        a été baptisé <em>Half adder.</em>
                        <img src="IMAGES/EN_ADD_HalfAdder_cascad.jpg" alt="">
                    </li>
                    <li>Faire directement l'étude d'un additionneur 3 bits <em>Full adder</em>
                        <img src="IMAGES/EN_ADD_3bits.jpg" alt="">
                    </li>
                </ol>

                <!-- ################################################################################################ -->
                <h3 id="HALFADDER">Etude d'un circuit Half adder</h3>
                <p class="InlineCenter">
                    <img class="inline" src="IMAGES/EN_ADD_HA_TVS.jpg" alt="">
                    <img class="inline" src="IMAGES/EN_ADD_HA_TVC.jpg" alt="">
                </p>
                <img src="IMAGES/EN_ADDR_HA_Sch.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="FULLADDER">Etude d'un circuit Full adder</h3>
                <img src="IMAGES/EN_ADD_FA_TVS.jpg" alt="">
                <img src="IMAGES/EN_ADD_FA_TVC.jpg" alt="">
                <img src="IMAGES/EN_ADD_FA_Sch.jpg" alt="">
                <p>On s'aperçoit qu'on obtient le même résultat que l'étude avec les Half-adders</p>

                <!-- ################################################################################################ -->
                <h3 id="ADDPR">Additionneur à propagation de la retenue</h3>
                <p>Pour additionner deux nombres de \(n\) bits, On utilise \(n\) additionneurs Full-adder chaînés en
                    cascade. On
                    obtient ce qu'on appelle un <b>Additionneur à propagation de la retenue</b></p>
                <img src="IMAGES/EN_ADD_APR.jpg" alt="">
                <p>Ce genre d'additionneur a l'avantage d'être facile à réaliser mais il manque de rapidité de
                    calcul.
                    En effet :</p>

                <ul>
                    <li>Le premier additionneur calcule la somme des bits de poids faible ainsi que
                        la retenue correspondante,</li>
                    <li>La retenue produite est transmise à l'additionneur suivant pour être utilisée dans son
                        calcul,
                    </li>
                    <li>Ce processus se répète jusqu'à ce que tous les bits soient additionnés,</li>
                    <li>La retenue doit donc se propager d'un bout à l'autre de l'additionneur, ce qui peut ralentir
                        l'opération si \(n\) est élevé</li>
                    <li>Le temps total de calcul est proportionnel à \(n\), ce qui en fait une architecture
                        relativement
                        lente pour
                        des opérations sur de grands nombres.
                    </li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="ADDUSAGE">Utilisation correcte d'un additionneur</h3>
                <p>La réalisation d'un additionneur ne pose pas de problème particulier. Par contre, son utilisation
                    demande quelques précautions pour éviter une mauvaise interprétation des résultats. On peut
                    distinguer plusieurs cas d'utilisations possibles. Dans ce tuto, nous allons considérer
                    seulement le
                    cas où les opérandes et le résultat ont le même nombre de bits. On va voir comment utiliser un
                    additionneur 4 bits avec des nombres signés et des nombres non signés
                </p>
                <img src="IMAGES/EN_ADD_addition4bits.jpg" alt="">
                <img src="IMAGES/EN_ADD_4b_adder.jpg" alt="">
                <!-- ################################################################################################ -->
                <h3 id="U4BADDER">Additionner 4 bits pour nombres non signés</h3>
                <ul>
                    <li>Avec 4 bits, on peut représenter les nombres non signés allant de 0 à 15,</li>
                    <img class="Float_R" src="IMAGES/EN_Unsigned.jpg" alt="">
                    <li>Si le résultat de l'addition est &gt; 15, il ne peut pas être représenté sur 4 bits, la
                        retenue
                        sortante \(C_{out} = C_3\) sert de <em>flag de débordement</em> pour indiquer si le résultat
                        est
                        correct ou non.
                        <img src="IMAGES/EN_ADD_4bUadder.jpg" alt="">
                    </li>
                    <li>\(C_{out}\) peut aussi servir pour la mise en cascade. On peut par exemple, cascader deux
                        additionneurs 4 bits pour réaliser un additionneur 8 bits
                        <img src="IMAGES/EN_ADD_8bUadder.jpg" alt="">
                    </li>

                </ul>


                <!-- ################################################################################################ -->
                <h3 id="S4BADDER">Additionner 4 bits pour nombres signés</h3>
                <ul>
                    <img class="Float_R" src="IMAGES/EN_SignedTable.jpg" alt="">
                    <li>Avec 4 bits, on peut représenter les nombres Signés allant de +0 à +7 et de -1 à -8 </li>
                    <li>Si le résultat de l'addition est &gt; +7 ou &lt; -8, il ne peut pas être représenté sur 4
                        bits.
                        La retenue sortante \(C_3\) ne permet pas de détecter le débordement : <br>
                        Par exemple : (+5)+(+4)=0101+0100=0 1001=(-7) , le résultat est faux et pourtant le flag
                        \(C_3\)
                        est resté à 0
                    </li>
                    <li>On va ajouter une sortie \(O_F\) <i>Overflow</i> qui servira de flag de débordement :
                        <ul>
                            <li>Si la retenue \(C_2\) est accessible : \(O_F=C_2\oplus C_3\)</li>
                            <li>Sinon on peut utiliser une des trois expressions : <br>
                                \(O_{F}=A_{3}B_{3}\:\bar{S}_3\:+\:\bar{A}_3\:\bar{B}_{3}\:S_3\:=\:\overline{A_3\:\oplus\:B_3}\:(S_3\:\oplus\:B_3\:)\)
                                <br>
                                \( O_F =\overline{ A_3 \oplus B_3 } \; (S_3 \oplus C_3) \) <br>
                                \( O_F = A_3 \oplus B_3 \oplus S_3 \oplus C_3 \)
                            </li>
                        </ul>
                    </li>
                </ul>
                <p>Si on réalise l'additionneurs à partir de Full-adders élémentaires, C2 sera accessible et on peut
                    utiliser le schéma suivant :</p>
                <img src="IMAGES/EN_ADD_4bSadderV1.jpg" alt="">
                <p>Si on réalise l'additionneurs à partir d'un circuit intégré (type 74LS283), C2 ne sera pas
                    accessible, on peut
                    utiliser le schéma suivant :</p>
                <img src="IMAGES/EN_ADD_4bSadderV2.jpg" alt="">
                <p>Si on utilise plusieurs additionneurs en cascade, l'Overflow est fabriqué au niveau du dernier
                    étage.
                </p>
                <img src="IMAGES/EN_ADD_8bSadder.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="SUBTOR">Soustracteur</h3>
                <p>Pour réaliser des soustraction, on peut faire l'étude d'un soustracteur exactement comme on l'a
                    fait
                    avec l'additionneur. On trouve d'ailleurs des structure assez similaire pour le
                    <i>Half-Substractor</i> et le <i>Full_Substractor</i>
                </p>
                <p>Au lieu de ça, on va exploiter une idée qui va nou permettre de nous permettre d'utiliser un
                    additionneur comme soustracteur. En effet :</p>
                <ul>
                    <li>\( A-B = A \textcolor{red}{+} (-B) \), la soustraction est ramenée à une addition</li>
                    <li>\( (-B) \) est obtenue en faisant le complément à 2 de B </li>
                    <li>Pour réaliser le complément à 2, on inverse tous les bits et on ajoute 1</li>
                    <li>Pour inverser tous les bits, on va appliquer l'expression \( X \oplus 1 = \bar{X} \) à tous
                        les
                        bits</li>
                    <li>Pour ajouter 1 on va forcer à 1 la retenue entrante \(C_{in}\) de l`additionneur</li>
                </ul>
                <img src="IMAGES/EN_ADD_Substractor.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="ADDSUBTOR">Additionneur/Soustracteur</h3>
                <p>Le circuit précédent peut facilement être adapté pour fonctionner soit en additionneur soit en
                    soustracteur. Il suffit remarquer que \( X \oplus 0 = X \)</p>
                <img src="IMAGES/EN_ADD_4bAddSub.jpg" alt="">
                <ul>
                    <li><b>Mode = 0</b> &rArr; \( S = 0 + A + B = A + B \)</li>
                    <li><b>Mode = 1</b> &rArr; \( S = 1 + A + \tilde{B} = A + (-B) = A-B \)</li>
                </ul><br>

                <p><strong>Pour utiliser correctement ce circuit, il faut adapter la sortie \(C_{out}\) pour
                        indiquer
                        correctement les débordement en mode <em>non signé</em> et en mode <em>signé</em></strong>
                </p>

                <!-- ################################################################################################ -->
                <h3 id="4BUADDSUB">Additionneur/Soustracteur 4 bits Non signé :</h3>
                <img src="IMAGES/EN_ADD_4bUaddsub.jpg" alt="">

                <li>La sortie \(CB\) permet de détecter les débordements :
                    <ul>
                        <li>En Mode addition, elle indique la retenue (Carry)</li>
                        <li>En Mode soustraction, elle indique l'emprunt (Borrow)</li>
                    </ul>
                </li>

                <p>Sur 4 bits, on peut représenter les nombres allant de 0 à 15</p>
                <ul>
                    <li><b>Mode = 0</b> &rArr; Additionneur, Voici quelques exemples :
                        <img src="IMAGES/EN_ADD_4bU_AS_tab1.jpg" alt="">
                    </li>
                    <li><b>Mode = 1</b> &rArr; Soustracteur, Voici quelques exemples :
                        <img src="IMAGES/EN_ADD_4bU_AS_tab2.jpg" alt="">
                    </li>
                </ul><br>

                <!-- ########################################################################## -->
                <h3 id="4BSADDSUB">Additionneur/Soustracteur 4 bits Signé :</h3>
                <img src="IMAGES/EN_ADD_4bSaddsub.jpg" alt="">
                <p>La sortie \(CB\) indique si le résultat est correct ou non</p>
                <p>Sur 4 bits, on peut représenter les nombres allant de -8 à +7</p>
                <ul>
                    <li><b>Mode = 0</b> &rArr; Additionneur, Voici quelques exemples :
                        <img src="IMAGES/EN_ADD_4bS_AS_tab1.jpg" alt="">
                    </li>
                    <li><b>Mode = 1</b> &rArr; Soustracteur, Voici quelques exemples :
                        <img src="IMAGES/EN_ADD_4bS_AS_tab2.jpg" alt="">
                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h2 id="7SEG">Afficheurs 7 segments</h2>
                <img src="IMAGES/EN_7segCircuit.jpg" alt="">
                <p>Un afficheur 7 segments est constitué de 7 segments lumineux disposés pour former un "8"
                    lorsqu'ils
                    sont tous activés. Le plus souvent, les segments sont réalisés par des LEDs. Chaque segment est
                    identifié par une lettre (de a à g) et peut être allumé ou éteint individuellement pour créer
                    différentes figures, principalement des chiffres. En plus des 7 segments, certains modèles
                    incluent
                    un point décimal pour afficher des valeurs non entières</p>
                <img src="IMAGES/EN_7seg_abc.jpg" alt="">
                <p>Pour minimiser le nombre de broches, les sept segment sont organisés soit en Anode commune, soit
                    en
                    Cathode commune.</p>

                <h3 id="7SEGAC">Anode Commune</h3>
                <ul>
                    <li>Les Anodes (bornes positive) de tous les segments sont reliées ensemble.</li>
                    <li>Pour illuminer un segment, on applique un <b>niveau bas</b> sur sa
                        cathode</li>
                    <img src="IMAGES/EN_7segAC1.jpg" alt="">
                    <img src="IMAGES/EN_7segAC2.jpg" alt="">
                </ul>

                <h3 id="7SEGCC">Cathode Commune</h3>
                <ul>
                    <li>Les cathodes (bornes négatives) de tous les segments sont reliées ensemble</li>
                    <li>Pour illuminer un segment, on applique un <b>niveau haut</b> sur son anode</li>
                    <img src="IMAGES/EN_7segCC1.jpg" alt="">
                    <img src="IMAGES/EN_7segCC2.jpg" alt="">
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="7SEG_DCR">Décodeur BCD - 7 segments :</h3>
                <p>Les afficheurs 7 segments sont principalement utilisés pour afficher des nombres. Les chiffres de
                    0 à
                    9 sont généralement représentés en binaire sur 4 bits, ce qui correspond au code DCB (Décimal
                    Codé
                    en Binaire), plus couramment désigné sous le terme BCD (Binary Coded Decimal). Cependant, comme
                    un
                    afficheur 7 segments possède 7 broches pour contrôler les segments, un décodeur est nécessaire
                    pour convertir l'information codée en BCD (4 bits) en signaux compatibles avec l'afficheur (7
                    bits),
                    afin d'activer les segments appropriés.</p>
                <img src="IMAGES/EN_7segDCR.jpg" alt=""><br>

                <h4>Etude d'un décodeur pour afficheur Cathode Commune</h4>
                <img src="IMAGES/EN_7segDCRtab.jpg" alt="">
                <img src="IMAGES/EN_7segDCRformules.jpg" alt="">
                <img src="IMAGES/EN_7segDCRsch.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="7SEG_PAC">Pilotage Anode commune</h3>
                <img src="IMAGES/EN_7segDRVAC.jpg" alt="">
                <ul>
                    <li>Il faut utiliser un décodeur pour Anodes Communes : Commande par niveau Bas,</li>
                    <li>Le décodeur peut avoir des sorties normales ou collecteur ouvert,</li>
                    <li>La valeur de R doit être calculée en fonction du seuil des LEDs et leur courant nominal (Vd,
                        Idn) :</li>
                    $$ R = \frac{V_{cd}-V_d}{I_{dn}} $$
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="7SEG_PCC">Pilotage Cathode commune</h3>
                <img src="IMAGES/EN_7segDRVCC.jpg" alt="">
                <ul>
                    <li>Il faut utiliser un décodeur pour Cathodes Communes : Commande par niveau Haut,</li>
                    <li>Le décodeur doit avoir des sorties normales (pas collecteur ouvert)</li>
                    <li>La valeur de R doit être calculée en fonction du seuil des LEDs et leur courant nominal (Vd,
                        Idn) ainsi que la tension de sortie du décodeur correspondant au courant Idn</li>
                    $$ R = \frac{V_{OH}(I_{dn})-V_d}{I_{dn}} $$
                </ul>
                <p>L'utilisation d'un décodeur avec sorties Open Collector peut se faire comme le montre la figure
                    ci-dessous. Je ne conseille pas cette structure car le montage consomme du courant que les LEDs
                    soit
                    allumées ou pas</p>
                <img src="IMAGES/EN_7segDRVCCoc.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="BIN2BCD">Binaire vers BCD</h3>
                <p>Normalement, les données sons codées en binaire dans les systèmes numériques. Si on désire les
                    afficher
                    sur des afficheurs 7 segments, il faut les convertir en BCD comme cela est indiqué sur la figure
                    ci
                    dessous</p>
                <img src="IMAGES/EN_7segBIN2BCD1.jpg" alt="">
                <p>La conversion binaire vers BCD est difficile à réaliser à l'aide de circuits MSI (TTL, CMOS…).
                    Il ya le circuit 74185 mais il se limite au nombre binaires 6 bits (0 à 63). On peut en associer
                    plusieurs pour traiter des nombres plus grand mais ça devient très vite très encombrant.
                </p>
                <p>Le plus simple est de la programmer sur un microcontrôleur ou <a class="lien" target="_blank"
                        href="../VHDL_LIB.html#BIN_BCD_4D_G">l'implanter sur un FPGA</a> à l'aide de
                    l'algorithme ci dessous :</p>
                <ul>
                    <li>On commence par former un grand registre constitué du binaire à droite et des chiffre BCD à
                        gauche,
                    </li>
                    <li>Pour un nombre binaire de N bits, on recommence N fois les deux actions suivantes:
                        <ul>
                            <li>Tester chacun des digits BCD, Si ≥ 5, rajouter 3 </li>
                            <li>Décaler le tout une position vers la gauche </li>
                        </ul>
                    </li>
                </ul>
                <p>Voici l'exemple de conversion du nombre 471 (9 bits : 9 itérations) :</p>
                <img src="IMAGES/EN_7segBIN2BCD2.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="7446-47-48">Les circuits 7446, 7447 et 7448</h3>
                <p>Les décodeurs 7446, 7447, et 7448 sont des circuits intégrés de la famille TTL utilisés pour
                    piloter
                    des afficheurs à sept segments</p>
                <ul>
                    <li><b>7446 :</b>
                        <ul>
                            <li>Pour afficheurs à anode commune : Commande par niveau bas</li>
                            <li>Sortie collecteur Ouvert</li>
                            <li>Convient pour les afficheur nécessitant une tensions d'alimentation élevée (jusqu'à
                                30V)
                            </li>
                        </ul>
                    </li>
                    <li><b>7447 :</b>
                        <ul>
                            <li>Pour afficheurs à anode commune : Commande par niveau bas</li>
                            <li>Sortie collecteur Ouvert</li>
                            <li>Convient pour les afficheur nécessitant une tensions d'alimentation relativement
                                élevée
                                (jusqu'à 15V)</li>
                        </ul>
                    </li>
                    <li><b>7448 :</b>
                        <ul>
                            <li>Pour afficheurs à cathode commune : Commande par niveau haut</li>
                            <li>Résistances intégrés</li>
                            <li>Courant de sortie relativement faible. Ne convient pas aux afficheurs demandant un
                                courant important</li>
                        </ul>
                    </li>
                </ul>
                <img src="IMAGES/EN_7seg74-46-47-48.jpg" alt="">
                <ul>
                    <li><b>LT</b> (Lamp Test) : Permet de tester l'afficheur. Si on l'active par un niveau bas (0), tous
                        les
                        segments sont allumés. </li>
                    <li><b>RBI</b> (Ripple Blanking Input). Cette broche est utilisée dans les applications avec
                        plusieurs afficheurs. On s'en sert pour faire de sorte que les 0 de gauche ne soit pas allumés.
                        Le fonctionnement est résumé dans le tableau ci-dessous.
                    </li>
                    <li><b>BI/RBO</b> (Blanking Input/Ripple Blanking Output). Cette broche peut fonctionner soit en
                        entrée soit en sortie :
                        <ul>
                            <li>Lorsque la broche est utilisée en entrée (BI), Si on l'active par un niveau bas (0),
                                tous les segments sont éteints. </li>
                            <li>Lorsque la broche est utilisée en sortie (RBO), Elle passe à 1 si l'afficheur est
                                allumé, elle passent à 0 si l'afficheur est éteint. il faut la connecter à l'entré RBI
                                de l'afficheur de droite pour l'informer si on est allumé ou éteint. Ainsi, il saura
                                quoi faire si la valeur qu'il doit afficher est égale à 0</li>
                        </ul>
                    </li>
                </ul><br>
                <img src="IMAGES/EN_7segBIRBO.jpg" alt=""><br>
                <p>Voici un exemple de branchement pour un afficheur à quatre digits :</p>
                <img src="IMAGES/EN_7seg-7446Cascad.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="CD4511">Le circuits 4511</h3>
                <p>C'est un décodeur BCD 7 segments de la famille CMOS</p>
                <ul>
                    <li>Pour afficheur cathode commune : Commande par niveau haut</li>
                    <li>Alimentation entre 6V et 15V</li>
                    <li>Jusqu'à 15mA par sortie</li>
                    <li>Entré LT (Lamp Test) : Allume tous les segments. Permet de tester l'afficheur</li>
                    <li>Entré BI (Blanking Input) : éteint tous les segments. Permet d'économiser l'énergie en
                        allumant l'afficheur que quand c'est nécessaire</li>
                    <li>Entrée LE (Latch Enable) : Permet de figer l'affichage à la valeur actuelle. Utile pour
                        stabiliser l'affichage dans certaines situations</li>
                </ul>
                <img src="IMAGES/EN_7seg4511.jpg" alt=""><br>


                <!-- ################################################################################################ -->
                <h2 id="SEQINTRO">Les Circuits séquentiels</h2>
                <p>Les circuits séquentiels constituent une classe importante des systèmes numériques. Leurs sorties
                    dépendent non seulement des entrées actuelles, mais aussi de l'état précédent du circuit.
                    Cette dépendance aux états permet à ces circuits de mémoriser des informations, ce qui les
                    distingue
                    des circuits combinatoires. </p>
                <p>Dans cette section, je vais introduire l'élément essentiel des circuit séquentiels, à savoir
                    <em>La
                        bascule</em>. Ensuite je parlerai des <b>registres</b>, des <b>registres à décalages</b> et
                    des
                    <b>compteurs</b>
                </p>

                <!-- ################################################################################################ -->
                <h3 id="CSBASE">Le circuit de base</h3>
                <p>Le circuit de base des circuits séquentiels est constitué de deux portes NAND <i>qui se mordent
                        la
                        queue</i></p>
                <p>Bien que ce circuit soit communément appelé bascule RS, je préfère donner ce nom au circuit
                    ci-dessous</p>
                <img src="IMAGES/EN_CS_Base.jpg" alt="">


                <!-- ################################################################################################ -->
                <h3 id="CSRS">La bascule RS</h3>
                <img src="IMAGES/EN_CS_RS.jpg" alt="">
                <p>La bascule RS (ou bascule SR, pour "Set-Reset") est une bascule bistable. Dès lors qu'elle est
                    placée
                    dans un état, elle va le maintenir grace à ces contre réactions.</p>

                <!-- ################################################################################################ -->
                <h3 id="CSRSH">La bascule RSH</h3>
                <img src="IMAGES/EN_CS_RSH.jpg" alt="">
                <p>l'ajout de l'entrée H transforme la bascule RS en une bascule synchrone. Les entrées ne sont
                    prises
                    en compte que lors de l'activation de l'horloge.</p>
                <p>L'entré H (Horloge) fonctionne comme une entrée de validation :</p>
                <ul>
                    <li><b>H = 0</b> &rArr; État mémoire. La sortie ne change pas même si les les entrées R et S
                        changent.
                        J'utilise souvent le terme <b>aveugle</b> pour signifier que dans cet état, la bascule ne
                        voit
                        pas ce qui se passe sur R et S</li>
                    <li><b>H = 1</b> &rArr; La bascule est active, la sortie se positionne conformément à la table
                        de
                        vérité. Tant que H est égale à 1, tout changement de R et S est répercuté en sortie.</li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="CSJK">La bascule JK</h3>
                <p>La bascule JK lève l'indétermination du cas : entrées = 11. Chaque fois qu'on arrive dans cet
                    état,
                    la sortie de la bascule change de niveau.</p>
                <img src="IMAGES/EN_CS_JK.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="CSJKH">La bascule JKH</h3>
                <img src="IMAGES/EN_CS_JKH.jpg" alt="">
                <p>l'ajout de l'entrée H transforme la bascule JK en une bascule synchrone. Les entrées ne sont
                    prises
                    en compte que lors de l'activation de l'horloge.</p>
                <p>L'entré H (Horloge) fonctionne comme une entrée de validation :</p>
                <ul>
                    <li><b>H = 0</b> &rArr; État mémoire. Bascule aveugle. Les changement de J et K sont ignorés.
                    </li>
                    <li><b>H = 1</b> &rArr; Bascule est active, la sortie se positionne conformément à la table de
                        vérité. Tant que H est égale à 1, tout changement de J et K est répercuté en sortie.</li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="CSFRONT">Bascule Réagissant sur front d'horloge</h3>
                <p>Dans certaines situations, les changements multiples des entrées d'une bascule lorsque H = 1
                    (niveau
                    actif) peuvent mener à des problèmes indésirables. On a alors conçu des bascules qui réagissent
                    uniquement sur le front de l'horloge (front montant ou descendant).</p>
                <p>Deux méthodes sont couramment utilisées pour réaliser ce type de bascules :</p>
                <ol>
                    <li>Insérer un détecteur de front dans le circuit de l'horloge pour délivrer une impulsion très
                        étroite au moment du changement de l'horloge. Durant la courte durée de cette impulsion, la
                        bascule entre dans son état actif et traduit l'état des entrées vers la sortie.
                        <img src="IMAGES/EN_CS_BRSFH.jpg" alt="">
                        Voici des exemples de détecteurs de front qui exploite le temps de propagation dans les
                        circuits
                        logiques
                        <ul>
                            <li>Détecteur du front descendant : <img src="IMAGES/EN_CS_DFD.jpg" alt=""> </li>
                            <li>Détecteur du front montant : <img src="IMAGES/EN_CS_DFM.jpg" alt=""> </li>
                            <li>Détecteur des deux fronts : <img src="IMAGES/EN_CS_D2F.jpg" alt=""> </li>
                        </ul>


                    </li>
                    <li>Utiliser une structure Maître-Esclave. On utilise deux bascules RS ou JK recevant des
                        Horloges
                        inversées. On peut facilement vérifier que le seul état des entrées qui arrive à la sortie
                        est
                        l'état présent sur les entrées juste avant le moment où l'horloge pase de 1 à 0
                        <img src="IMAGES/EN_CS_MasterSlave.jpg" alt="">
                        <ul>
                            <li><b>RS Maître-Esclave :</b>
                                <img src="IMAGES/EN_CS_RS_MS.jpg" alt="">
                            </li>
                            <li><b>JK Maître-Esclave :</b>
                                <img src="IMAGES/EN_CS_JK_MS.jpg" alt="">
                            </li>

                        </ul>
                    </li>
                </ol>

                <!-- ################################################################################################ -->
                <h3 id="CSCONV">Convention de dessin</h3>
                <ul>
                    <li>Bascule active pendant le <em>Nivaux haut</em> de l'horloge
                        <img src="IMAGES/EN_CS_bascNH.jpg" alt="">
                    </li>
                    <li>Bascule active pendant le <em>Nivaux bas</em> de l'horloge
                        <img src="IMAGES/EN_CS_bascNB.jpg" alt="">
                    </li>
                    <li>Bascule active pendant le <em>Front montant</em> de l'horloge
                        <img src="IMAGES/EN_CS_bascFM.jpg" alt="">
                    </li>
                    <li>Bascule active pendant le <em>Front descendant</em> de l'horloge
                        <img src="IMAGES/EN_CS_bascFD.jpg" alt="">
                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="BASCULED">La bascule D</h3>
                <p>La bascule D (ou bascule "data") est une bascule disposant d'une seule entrée de données,
                    notée <b>D</b>, et d'une sortie Q. Elle est conçue pour simplifier le
                    stockage d'une valeur binaire.
                    Elle peut être sensible au niveau de l'horloge (niveau haut ou bas) ou déclenchée par un front
                    d'horloge (montant
                    ou descendant). Lorsqu'elle est activée par l'horloge (au niveau ou au front), l'état présent
                    sur
                    l'entrée D est directement transféré à la sortie Q, où il est conservé jusqu'à la prochaine
                    activation</p>

                <h4>Bascule D active au niveau haut de H :</h4>
                <img src="IMAGES/EN_CS_BD_HNH.jpg" alt=""><br>
                <h4>Bascule D active au front descendant de H :</h4>
                <img src="IMAGES/EN_CS_BD_HFD.jpg" alt=""><br><br>

                <h4>Transformer une bascule JK ou RS en bascule D</h4>
                <p>On peut constater sur les table de vérité que si J &ne; K alors la sortie suit J. De même si R
                    &ne; S
                    alors la sortie suit S. Il suffit donc d'ajouter un inverseur pour obtenir une bascule D</p>
                <img src="IMAGES/EN_CS_BD_JKRS.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="FRORÇAGE">Entrées de forçage CLEAR et PRESET</h3>
                <p>Les entrées de forçage sont prioritaires sur les autres entrées. Pae exemple, pour une bascule JK
                    :
                </p>
                <ul>
                    <li>L'entrée <em>C</em> (Clear) force la sortie à <em>0</em> &forall; J, K, H </li>
                    <li>L'entrée <em>P</em> (Preset) force la sortie à <em>1</em> &forall; J, K, H </li>
                </ul>
                <img src="IMAGES/EN_CS_Force.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id=""></h2>

                <br><br><br>
                <!-- ################################################################################################ -->
                <h2 id="REGINTRO">Les Registres</h2>
                <h3>Registre à chargement sur front d'horloge</h3>
                <img src="IMAGES/EN_CS_REG.jpg" alt="">
                <ul>
                    <li>Un registre est une association de N bascules réalisant la fonction de mémoire N bits</li>
                    <li>Au front d'horloge, l'information \(A_3 A_2 A_1 A_0\) est copiée dans \(Q_3 Q_2 Q_1 Q_0\) et y
                        reste jusqu'au
                        prochain front
                    </li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="REGLATCH">Registre Latch</h3>
                <img src="IMAGES/EN_CS_REG_Latch.jpg" alt="">
                <ul>
                    <li>On utilise des bascules actives sur niveau de l'horloge</li>
                    <li>Tant que l'horloge est à 1, les sorties Q suivent les entrées A </li>
                    <li>Quand l'horloge passe à zéros, les sorties Q restent mémorisées <i>(latchées)</i> jusqu'à ce que
                        l'horloge passe de nouveau à 1
                    </li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="REG273">Le Registre 74LS273</h3>
                <ul>
                    <li>Registre 8 bits de la famille TTL</li>
                    <li>Chargement sur front montant de l'horloge</li>
                    <li>Entrée CLEAR active au niveau bas</li>
                </ul>
                <img src="IMAGES/EN_CS_REG_273.jpg" alt="">
                <img src="IMAGES/EN_CS_REG_273_sch.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="SHIFTREGI">Les Registres à décalage</h3>
                <img src="IMAGES/EN_CS_SHIFTREG.jpg" alt="">
                <ul>
                    <li>A chaque coup d'horloge, le contenu d'une bascule est remplacé par celui de la bascule située à
                        sa gauche &rArr; tous les bits sont alors décalés vers la droite, </li>
                    <li><b>ES :</b> Entrée série, </li>
                    <li><b>ABCD :</b> Sorties parallèle,</li>
                    <li><b>SS :</b> Sorties série </li>
                    <li><b>H :</b> Horloge </li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="PLOAD">Chargement parallèle</h3>
                <img src="IMAGES/EN_CS_SR_PL.jpg" alt="">
                <ul>
                    <li>En plus des N sorties \(Q_n\;...\; Q_2 Q_1 Q_0\), le registre à décalage dispose de N entrées de
                        \(A_n \;...\; A_2 A_1 A_0\) ainsi qu'une entrée de contrôle de chargement PL (Parallel Load)
                    </li>
                    <li>Quand l'entré PL est activée, le entrées \(A_n \;...\; A_2 A_1 A_0\) sont chargée dans
                        \(Q_n\;...\; Q_2 Q_1 Q_0\)</li>
                    <li>Le chargement peut être synchrone ou Asynchrone :
                        <ul>
                            <li><b>Chargement Asynchrone :</b> Le chargement se fait immédiatement au moment de
                                l'activation de l'entrée PL</li>
                            <li><b>Chargement Synchrone :</b> Le chargement se fait au coup d'horloge qui suit
                                l'activation de l'entrée PL</li>
                        </ul>
                    </li>
                    <li>Quand l'entrée <b>PL</b> n'est pas activée, le registre fonctionne en mode décalage.
                        C'est pour cette raison que cette entrée est des fois baptisée <b>SL</b> (Shift/Load) parce
                        qu'elle permet de basculer entre le mode décalage et le mode chargement. Il arrive aussi qu'on
                        la nomme tout simplement <b>L</b> (Load)</li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="SYPLOAD">Chargement parallèle Synchrone</h3>
                <p>Pour que le chargement soit synchronisé sur le front d'horloge, il faut que les données entrent dans
                    les bascule par l'entré D. Pour ce faire, on place un petit multiplexeur 2:1 devant chaque bascule
                    pour connecter l'entrée D soit vers la donnée à charger soit vers la sortie de la bascule
                    précédente. Tous les multiplexeurs sont contrôlées par l'entrée PL</p>
                <img src="IMAGES/EN_CS_SR_SPL.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SR_SPL_SCH.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="ASYPLOAD">Chargement parallèle Asynchrone</h3>
                <p>Pour que le chargement soit indépendant de l'horloge, on va passer par les entrées <b>Clear</b> et
                    <b>Preset</b>
                </p>
                <img src="IMAGES/EN_CS_SR_APL.jpg" alt="">
                <p>Les bascules utilisées on un Clear et Preset actif au niveau bas,</p>
                <ul>
                    <li><b>PL = 1</b> &rArr; \(C=1 ~,~ P=1\), &rArr; Bascule libre &rArr; Mode décalage</li>
                    <li><b>PL = 0</b> &rArr; \(C=A ~,~ P=\bar{A}\) :
                        <ul>
                            <li>Si A=0 &rArr; C=0, P=1 &rArr; Clear &rArr; Q = 0 &equiv; Chargement de A</li>
                            <li>Si A=1 &rArr; C=1, P=0 &rArr; Preset &rArr; Q = 1 &equiv; Chargement de A</li>
                        </ul>
                    </li>
                </ul>
                <p>On remarque que l'entrée \(PL\) est active au niveau bas. il aurait été plus juste de l'appeler
                    \(\overline{PL}\)</p><br>


                <!-- ################################################################################################ -->
                <h3 id="BIDSR">Registre à décalage bidirectionnel</h3>
                <img src="IMAGES/EN_CS_SR_BIDIR.jpg" alt="">
                <p>On a rajouté un petit multiplexeur 2:1 devant chaque entrée D pour connecter soit la bascule de
                    gauche soit la bascule de droite</p>
                <ul>
                    <li><b>Dir = 0</b> &rArr; décalage à gauche</li>
                    <li><b>Dir = 1</b> &rArr; décalage à droite</li>
                    <li><b>ESG :</b> Entrée série gauche</li>
                    <li><b>ESD :</b> Entrée série droite</li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="SRUNIV">Registre à décalage universel</h3>
                <img src="IMAGES/EN_CS_SR_UNIV.jpg" alt="">
                <img src="IMAGES/EN_CS_SR_UNIV_tab.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id="ASYCTR">Les compteurs Asynchrones</h2>
                <p>On obtient un compteur Asynchrone en connectant en cascade des bascules JK de la façon suivante :</p>
                <ul>
                    <li>On utilise des bascules qui réagissent au front descendant de l'horloge</li>
                    <li>On connecte la sortie Q d'une bascule à l'entrée Horloge de la bascule suivante</li>
                    <li>Les entrée J et K doivent être forcée à 1 : A chaque coup d'horloge, la sortie Q change d'état
                    </li>
                </ul>
                <img src="IMAGES/EN_CS_CTR_ASY.jpg" alt="">
                <img src="IMAGES/EN_CS_CTR_ASY_crono.jpg" alt=""><br>

                <h4>Avantage est inconvénients :</h4>
                <p>Les compteur asynchrones ont l'avantage de la simplicité mais l'inconvénient de la propagation. En
                    effet, chaque
                    bascule change un temps de propagation après la bascule précédente ce qui engendre un lenteur de
                    fonctionnement et la génération d'états transitoires indésirables </p>
                <img src="IMAGES/EN_CS_CTR_ASY_transitoir.jpg" alt="">
                <p>Chaque état transitoire dure le temps de propagation de technologie utilisée. Par exemple, pour la
                    famille TTL, le temps de propagation est de 10 ns</p>

                <!-- ################################################################################################ -->
                <h3 id="ASYDCTR">Décompteur Asynchrone</h3>
                <p>Pour obtenir un décompteur asynchrone, on peut procéder de deux façons :</p>
                <ol>
                    <li>Utiliser le même montage que celui du compteur mais avec des bascules qui réagissent au
                        <b>front montant </b> de l'horloge
                        <img src="IMAGES/EN_CS_CTR_DCR1.jpg" alt="">
                    </li>
                    <li>Utilise des bascules qui réagissent au front descendant de l'horloge mais chaque bascule est
                        déclenchée par la sortie \(\bar{Q}\) de la bascule précédente
                        <img src="IMAGES/EN_CS_CTR_DCR2.jpg" alt="">
                    </li>
                </ol>


                <!-- ################################################################################################ -->
                <h3 id="MODULON">Comptage incomplet</h3>
                <p>un compteur \(n\) bits est un compteur modulo \(2^n\). Par exemple un compteur 4 bits est un compteur
                    modulo 16, il compte de 0 à 15 et revient à 0</p>
                <p>Avec un compteur asynchrone, la façon la plus simple de réaliser un compteur modulo \(N\) où \(N \lt
                    2^n\) consiste à détecter la valeur \(N\) sur les sorties et de déclencher un signal de "remise à
                    zéro" pour réinitialiser les sorties à 0. Cette méthode n'est pas parfaite à cause de la latence due
                    au temps de propagation des portes logiques utilisées pour détecter la valeur \(N\). Pendant ce temp
                    de latence, la valeur \(N\) qui ne doit pas faire partie du cycle comptage va exister pendant une
                    durée serte très courte mais qui n'est pas nulle.</p>
                <img src="IMAGES/EN_CS_CTR_ModulN.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_CTR_modul10.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="DIVFREQ">Diviseur de fréquence</h3>
                <p>Une seule bascule peut être utilisée pour diviser la fréquence par 2 </p>
                <img src="IMAGES/EN_CS_CTR_DivFreq2.jpg" alt="">
                <p>Un compteur modulo N peut être utilisé pour diviser la fréquence par N. Le signal de sortie doit être
                    pris sur le MSB du compteur</p>
                <img src="IMAGES/EN_CS_CTR_DivFreqN.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_CTR_DivFreq5.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_CTR_DivFreq5Chrono.jpg" alt=""> <br>
                <p>Pour le diviseur par 5, j'ai fait exprès d'utiliser un compteur 4 bits. Normalement 3 bits auraient
                    suffit. Mais c'est dans le cas où on utilise un compteur intégré. Avec cette situation, il faut
                    faire attention, le MSB c'est C et non D</p><br>

                <!-- ################################################################################################ -->
                <h3 id="CASCAASY">Cascadage asynchrone</h3>
                <p>La mise en cascade de compteurs asynchrones permet d'augmenter le nombre de
                    bits du comptage en connectant plusieurs compteurs en série</p>
                <ul>
                    <li>Le MSB du compteur i est appliqué à l'horloge du compteur i+1 (suivant)</li>
                    <li>Chaque fois qu'un compteur termine son cycle et repasse à 0, le compteur suivant s'incrémente
                    </li>
                </ul>
                <img src="IMAGES/EN_CS_CTR_CascadAsy.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="CASCADBCD">Compteur BCD</h3>
                <p>On obtient un compteur BCD en cascadant des compteurs modulo 10 </p>
                <img src="IMAGES/EN_CS_CTR_BCD.jpg" alt=""> <br>

                <!-- ################################################################################################ -->
                <h3 id="74LS93">Le compteur 74LS93</h3>
                <img src="IMAGES/EN_CS_CTR_93.jpg" alt="">
                <img src="IMAGES/EN_CS_CTR_93_pinout.jpg" alt="">
                <img class="w300" src="IMAGES/EN_CS_CTR_93_Sch.jpg" alt="">

                <p>Le 74LS93 est un compteur asynchrone populaire de la famille TTL. Il a une conception intelligente :
                </p>
                <ul>
                    <li>La bascule A n'est pas chaînée avec les 3 autres. Elle peut être utilisée toute seule et les 3
                        autres peuvent être utilisées à part pour réaliser un compteur modulo 8 ou plus faible</li>
                    <li>Pour réaliser un compteur module 3, 5, 6, 9 , 10, 12 ou 14, on n'a pas besoin d'une porte NAND
                        externe, celle qui est intégrée fait l'affaire</li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="74LS90">Le compteur 74LS90</h3>
                <img src="IMAGES/EN_CS_CTR_90.jpg" alt="">
                <p>Le 74LS90 est une décade asynchrone populaire de la famille TTL. Il a une architecture similaire au
                    93 avec des entrées de remise à 9 en plus</p>

                <!-- ################################################################################################ -->
                <h3 id="BCD60">Compteur BCD modulo 60</h3>
                <p>Voici l'exemple d'un compteur BCD modulo 60 avec affichage. Convient pour compter les secondes ou les
                    minutes.</p>
                <img src="IMAGES/EN_CS_CTR_BCD60.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="BCD24">Compteur BCD modulo 24</h3>
                <p>Voici l'exemple d'un compteur BCD modulo 24 avec affichage. Convient pour compter les
                    heures.</p>
                <img src="IMAGES/EN_CS_CTR_BCD24.jpg" alt=""><br>


                <!-- ################################################################################################ -->
                <h2 id="SYNCTR">Les compteurs Synchrones</h2>
                <p>Les compteurs synchrones peuvent aussi être réalisés à l'aide de bascule JK. A la différence des
                    compteurs asynchrones, toutes les bascules reçoivent la même horloge. Dès lors, à chaque
                    coup d'horloge toutes les sorties changent en même temps, il n'y aura pas de latence ni états
                    transitoires.
                </p>
                <img src="IMAGES/EN_CS_SCTR_CLK.jpg" alt="">
                <p class="InlineCenter"><span class="encadre">Que doit on mettre sur les J et les K pour que ça compte
                        ?</span></p>
                <p>On connaît la séquence de comptage. Au coup d'horloge, on sait pour chaque bascule si elle doit
                    changer d'état ou non, On en déduit le J et le K qu'il faut lui appliquer. Pour nous faciliter le
                    travail, on va établir la table de transition de la bascule JK </p>
                <img src="IMAGES/EN_CS_SCTR_TransTable.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="4BSYNCTR">Compteur Synchrone 4 bits</h3>
                <p>On commence par dresser une Table avec la séquences de comptage des sorties A, B, C et D et les
                    valeurs adéquates des entrées J et K</p>
                <img src="IMAGES/EN_CS_SCTR_4BTable.jpg" alt="">
                <h4>Remplissage de la table :</h4>
                <p>Au départ on est dans l'état DCBA = 0000. Au prochain coup d'horloge on doit aller à l'état DCBA =
                    0001. </p>
                <p>Pour la bascule A, on a une transition 0&rarr;1, on consulte la table de transition, on trouve JK=1x
                </p>
                <p>Pour les autres bascules, il faut rester à 0, la table de transition donne JK=0x</p>
                <p>On continue comme ça pour compléter la table.</p>
                <p>Maintenant, il faut trouver les expression des J et K en fonction de A, B, C et D. il y a du boulot
                    😊</p><br>
                <p>Pour la bascule A, c'est vite fait, on constate qu'elle change à chaque coup d'horloge &rArr; J=1, K=
                    1</p>
                <p>Voici les tables de Karnaugh pour tous les J et les K</p>
                <img src="IMAGES/EN_CS_SCTR_KarnT1.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SCTR_KarnT2.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SCTR_4BSch.jpg" alt="">
                <p><b>On remarque qu'on a une relation de récurrence 1, A, AB, ABC, ABCD ... facile à généraliser pour
                        construire des compteurs plus grands</b></p>

                <!-- ################################################################################################ -->
                <h3 id="4BSYNCTRPL">Version avec chargement parallèle Asynchrone</h3>
                <img src="IMAGES/EN_CS_SCTR_4bPL.jpg" alt="">
                <p>Le comptage est synchrone, le chargement est Asynchrone</p>

                <!-- ################################################################################################ -->
                <h3 id="4BSYNDCTR">Décompteur Synchrone 4 bits</h3>
                <p>Avec une étude similaire, on obtient : </p>
                <img src="IMAGES/EN_CS_SCTR_4bDCTR.jpg" alt=""><br>
                <b>Là aussi, on remarque une récurrence facile à généraliser : \( 1, ~\bar{A},~
                    \bar{A}\bar{B},~\bar{A}\bar{B}\bar{C}~...\)</b><br>

                <!-- ################################################################################################ -->
                <h3 id="CTRDCTRSYN">Compteur/Décompteur Synchrone</h3>
                <p>On va encore utiliser l'opérateur XOR (que j'adore😊) pour choisir entre \( A \) et \(\bar{A}\) , \(
                    B \) et \(\bar{B}\) ... </p>
                $$ 0 \oplus X = X \quad,\quad 1 \oplus X = \bar{X}$$
                <img src="IMAGES/EN_CS_SCTR_CTR-DCTR.jpg" alt="">
                <ul>
                    <li><b>DIR = 0 :</b> Compteur</li>
                    <li><b>DIR = 1 :</b> Décompteur</li>
                </ul>
                <p>Voici une version avec chargement parallèle</p>
                <img src="IMAGES/EN_CS_SCTR_CTR-DCTR_PL.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="DECADESYNC">Décade Synchrone</h3>
                <p>La technique qui consiste à detecter le 10 et le replacer par 0 est une technique Asynchrone donc
                    inadéquate pour réaliser une décade synchrone. On va donc refaire l'étude de A à Z</p>
                <img src="IMAGES/EN_CS_SCTR_DCAD_Tbl.jpg" alt="">
                <img src="IMAGES/EN_CS_SCTR_KarnT3.jpg" alt="">
                <img src="IMAGES/EN_CS_SCTR_KarnT4.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SCTR_DCAD.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="CASCADSYNC">Mise en cascade des compteurs synchrones</h3>
                <p>La mise en cascade doit être synchrone. Tous les compteurs doivent recevoir la même Horloge</p>
                <img src="IMAGES/EN_CS_SCTR_CascadSync.jpg" alt="">
                <p>Dans ces conditions, tous les compteurs fonctionneront simultanément et on n'aura pas le comptage
                    désiré. La règle de comptage doit être la suivante :</p>
                <ul><em>
                        <li>Le compteur de plus faible poids s'incrémente toujours</li>
                        <li>Pour les autres, un compteur ne doit s'incrémenter que si les compteurs de rang inférieur
                            sont tous à leur valeur maximale</li>

                    </em></ul>
                <p>Prenons le cas d'un comptage BCD (tous les compteur sont des décades, la valeur max de chaque
                    compteur est 9) :</p>
                <ul>
                    <li>Si la situation actuelle est <b>0099</b>, au prochain coup d'horloge :
                        <ul>
                            <li>Le compteur des unités doit s'incrémenter car il doit toujours le faire,</li>
                            <li>Le compteur des dizaines doit s'incrémenter car le compteur à sa droite contient 9</li>
                            <li>Le compteur des centaines doit s'incrémenter car les deux compteurs à sa droite sont à 9
                            </li>
                            <li>Le compteur des milliers ne doit pas s'incrémenter car les trois compteurs à sa droite
                                ne sont pas tous les trois à 9</li>
                            <li>On passe donc à <b>0100</b></li>
                        </ul>
                    </li>
                    <li>Si la situation actuelle est <b>0997</b>, au prochain coup d'horloge :
                        <ul>
                            <li>Le compteur des unités doit s'incrémenter car il doit toujours le faire,</li>
                            <li>Le compteur des dizaines ne doit pas s'incrémenter car le compteur à sa droite contient
                                7, </li>
                            <li>Le compteur des centaines ne doit pas s'incrémenter car les deux compteurs à sa droite
                                ne sont pas tous les deux à 9</li>
                            <li>Le compteur des milliers ne doit pas s'incrémenter car les trois compteurs à sa droite
                                ne sont pas tous les trois à 9</li>
                            <li>En définitive, il n'y a que le compteur des unités qui s'incrémente et on passe à
                                <b>0998</b>
                            </li>
                        </ul>
                    </li>

                </ul><br>
                <p>Pour réaliser cet objectif, on va rajouter à chaque compteur une entrée de <em>validation V</em> et
                    une sortie de <em>retenue R</em>, et on va les connecter en cascade comme suit : </p>
                <img src="IMAGES/EN_CS_SCTR_CascadSyncSch.jpg" alt="">
                <ul>
                    <li>L'entrée de validation V permet d'autoriser de d'interdire le comptage :
                        <ul>
                            <li>V = 0 &rArr; arrêt</li>
                            <li>V = 1 &rArr; comptage</li>
                        </ul>
                    </li>
                    <li>La sortie de retenue R passe à 1 quand le compteur contient sa valeur max <b>et</b> son entrée
                        de validation V est active signifiant que les compteurs précédents sont aussi à leur valeur max.
                        Cette sortie servira à informer le compteur suivant qu'il pourra s'incrémenter pendant le coup
                        d'horloge suivant.</li>
                </ul><br>
                <img src="IMAGES/EN_CS_SCTR_4Bcascad.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SCTR_DecdCascad.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="CTRSYNBASCD">Compteur synchrone avec des bascules D</h3>
                <p>On procède de la même façon qu'avec les bascules JK</p>
                <img src="IMAGES/EN_CS_SCTR_DFF_Table.jpg" alt="">
                <p>l'étude de Karnaugh permet d'obtenir les résultats :</p>
                <img src="IMAGES/EN_CS_SCTR_DFF_Formules.jpg" alt="">
                <img src="IMAGES/EN_CS_SCTR_DFF_SCH.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="DCTRSYNDFF">Décompteur synchrone avec des bascules D</h3>
                <img src="IMAGES/EN_CS_SCTR_DFF_DCTR_Table.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SCTR_DFF_DCTR_Formules.jpg" alt=""><br>
                <img src="IMAGES/EN_CS_SCTR_DFF_DCTR.jpg" alt=""><br>
                <p>On peut combiner les deux pour réaliser un compteur/décompteur :</p>
                <img src="IMAGES/EN_CS_SCTR_DFF_CTR-DCTR.jpg" alt=""><br>


                <!-- ################################################################################################ -->
                <h2 id="DIGITCIRCUIT">Technologies des circuits numériques</h2>
                <p>Nous vivons dans un monde analogique, et non numérique, où les tensions, les courants et autres
                    grandeurs physiques varient de manière continue dans les circuits réels. <br>
                    La logique numérique simplifie ces complexités en réduisant l'infinité des valeurs réelles d'une
                    grandeur physique à deux états logiques : 0 et 1. Cette simplification permet d'analyser et de
                    concevoir des circuits numériques de manière fonctionnelle, en s'appuyant à la fois sur des outils
                    mathématiques, comme l'algèbre de Boole adaptée à l'ensemble {0, 1}, et sur l'utilisation de
                    composants électroniques en commutation capables de représenter physiquement ces deux états.</p>

                <!-- ################################################################################################ -->
                <h2 id="COMTOR">Composants en commutation</h2>
                <p>L'élément essentiel de l'électronique digitale est le <b>commutateur</b>. C'est un dispositif qui
                    permet d'établir ou d'interrompre une connexion électrique entre deux points d'un circuit.</p>
                <ul>
                    <li>En position fermée, le commutateur permet au <b>courant</b> de circuler.</li>
                    <li>En position ouverte, il interrompt le flux de <b>courant</b>.</li>
                </ul>
                <p>L'information <b>présence</b> ou <b>absence</b> de courant peut être transformé en une information
                    <b>tension
                        faible</b> ou <b>tension forte</b> à l'aide du circuit suivant :
                </p>
                <img src="IMAGES/EN_COM_COM.jpg" alt="">
                <ul>
                    <li>En position fermée : \(Vs~=~0\)</li>
                    <li>En position ouverte : \(Vs~=~V_{cc}\)</li>
                </ul><br>

                <h3>Caractéristiques statiques d'un commutateur idéal :</h3>
                <ul>
                    <li>En position fermée : \(R_{com}~=~0\) , \(Vs~=~0\) , \(I:~important\)</li>
                    <li>En position ouverte : \(R_{com}~=~ \infty\) , \(I=0\) , \(Vs~=~V_{cc}\)</li>
                </ul><br>

                <h3>Caractéristiques statiques d'un commutateur Réel :</h3>
                <p>Dans les circuits numériques, on utilise essentiellement des diodes, des transistors bipolaire et des
                    transistors MOS comme commutateurs. Ces derniers n'ont ni une résistance infinie à l'état
                    ouvert, ni une résistance nulle à l'état fermé</p>
                <ul>
                    <li>En position fermée : \(R_{com}: faible \) , \(Vs: faible~(\approx0) \) , \(I:~important\)</li>
                    <li>En position ouverte : \(R_{com}: très~élevée \) , \( I \approx 0~(courant~de~fuite) \) ,
                        \(Vs~\approx~V_{cc}\)</li>
                </ul>
                <img src="IMAGES/EN_COM_Stat.jpg" alt=""><br>

                <h3>Caractéristiques dynamique d'un commutateur Réel :</h3>
                <p>Les caractéristiques dynamiques d'un commutateur Traduisent le comportement transitoire lors du
                    passage
                    d'un état à un autre. </p>
                <img src="IMAGES/EN_COM_Dyn.jpg" alt="">
                <ul>
                    <li>\(t_d\) :<b> Delay Time (Temps de retard) :</b> C'est le temps nécessaire pour qu'un commutateur
                        commence à répondre à un signal d'activation. Dépend de la capacité parasite et aux résistances
                        internes du commutateur</li>
                    <li>\(t_r\) :<b> Rise Time (Temps de montée) :</b> C'est le temps nécessaire pour que le courant
                        passe d'une valeur faible (10 % de la pleine échelle) à une valeur élevée (90 %
                        de la pleine échelle)</li>
                    <li>\(t_s\) :<b> Storage Time (Temps de stockage) :</b> Ce paramètre est surtout associé au
                        transistor bipolaire. C'est le temps que met un commutateur à évacuer
                        les charges accumulées dans la base lorsqu'il passe de l'état ON à l'état OFF.
                    </li>
                    <li>\(t_f\) : <b>Fall Time (Temps de descente) :</b> C'est le temps nécessaire pour que le
                        courant passe d'une valeur élevée (90 % de la pleine échelle) à une valeur faible (10 % de la
                        pleine échelle).</li>
                    <li>\(t_{on}\) : <b>Turn-On Time (Temps d'allumage) :</b> C'est la somme du <i>delay time</i> et du
                        <i>rise time</i>.
                        C'est le temps total nécessaire pour que le commutateur passe de l'état OFF à l'état ON.
                    </li>
                    <li>\(t_{off}\) : <b>Turn-Off Time (Temps d'extinction) :</b> C'est la somme du <i>storage time</i>
                        et du
                        <i>fall time</i>.
                        C'est le temps total nécessaire pour que le commutateur passe de l'état ON à l'état OFF.
                    </li>
                </ul>
                <p><em>Ces paramètres indiquent la rapidité avec laquelle le commutateur change d'état. Ils jouent un
                        rôle essentiel dans les applications à haute fréquence nécessitant des transitions rapides.
                        Ils dépendent principalement de la capacité structurelle du commutateur, de
                        ses résistances internes, ainsi que des résistances du circuit de commande. L'un des principaux
                        enjeux de l'industrie électronique actuelle est de concevoir des composants ayant les temps de
                        commutation les plus réduits possibles</em></p>
                <p>Pour réduire les capacités structurelles des commutateurs, les composants électroniques sont conçus
                    avec des dimensions de plus en plus petites. Cette miniaturisation permet de diminuer la quantité de
                    charge stockée, améliorant ainsi les performances dynamiques. Cependant, elle atteint ses limites en
                    raison de phénomènes physiques tels que l'effet tunnel quantique, la fiabilité des matériaux à
                    l'échelle nanométrique, et les difficultés de fabrication. <br>

                    En parallèle, pour réduire les temps de charge et de décharge des capacités structurelles, on
                    cherche à diminuer les résistances internes et celles des circuits de commande. Bien que cela
                    améliore les vitesses de commutation, cela entraîne une augmentation des courants ce qui provoque
                    des problèmes de surchauffe à cause de la dissipation thermique, nécessitant des systèmes de
                    refroidissement de plus en plus volumineux.
                    Ainsi, l'optimisation des temps de commutation est un équilibre délicat entre performance, fiabilité
                    et gestion thermique</p>

                <!-- ################################################################################################ -->
                <h3 id="DIODCOMM">La diode en commutation</h3>
                <p>La diode est un composant qui n'a que deux bornes. Elle n'a pas une entrée qui peut servir de
                    contrôle. De ce fait, elle sera commandée par le sens de la tension qui lui est appliquée. Il n'y a
                    pas de séparation entre le circuit de commande est le circuit commandé. Nous en avons parlé dans la
                    section <a target="_blank" href="ElecBase.html#DIODEINTRO">Electronique de base</a>
                    <img src="IMAGES/EN_COM_Diode.jpg" alt="">
                </p><br>
                <h4>Comportement dynamique</h4>
                <img src="IMAGES/EN_COM_Diod_Dyn.jpg" alt="">
                <p>Lors du passage de l'état ON à l'état OFF, la diode présente un comportement dynamique particulier :
                    elle conduit dans le sens inverse pendant un très court instant. Un courant inverse, de même
                    intensité que le courant
                    direct, circule temporairement. Ce courant est dû aux porteurs de charge non recombinés, rappelés
                    par la tension inverse. La durée de ce phénomène est appelée temps de recouvrement inverse
                    (\(t_{rr}\) , reverse recovery time)</p><br>

                <h4>Paramètre importants :</h4>
                <ul>
                    <li><b>Tension inverse maximale \(V_{rmax}\) : </b> C'est la tension maximale que la diode peut
                        supporter
                        en polarisation inverse avant d'être détruite par claquage.</li>
                    <li><b>Courant direct maximal \(I_{Fmax}\) : </b> C'est courant maximal que la diode peut conduire
                        en polarisation directe avant d'être détruite par échauffement</li>
                </ul>

                <p>Voici quelques caractéristiques de la diode <b>1N4148</b> : </p>
                <ul>
                    \(V_{rmax}\) = 75V <br>
                    \( I_{rmax}(V_{rmax}) \) = (25 nA à 25 °C) , (50 µA à 150 °C) <br>
                    \(C_{max}\) = 4 pF <br>
                    \(t_{rrmax}(I_F=10mA)\) = 4ns <br>
                    \( I_{Fmax} \) = 75 mA.
                </ul><br>

                <p>On remarque que Le courant inverse d'une diode dépend fortement de la température, car l'élévation de
                    température accroît la génération de porteurs de charge (paire électron trou) dans la jonction en
                    cassant des liaisons de valence.
                    Il est donc important de prendre en compte ce phénomène dans les circuits : à très haute
                    température, le courant de fuite inverse peut devenir significatif, et la diode ne peut plus être
                    considérée comme complètement bloquée. <br>
                    Toutefois, il arrive que cette propriété soit mise à profit en utilisant la diode polarisée en
                    inverse comme capteur de
                    température dans certaines applications.
                </p>
                <p>n'hésitez pas consulter <a target="_blank" href="ElecBase.html#DIODEXMPL">les exemples</a> dans la
                    section 'Electronique de Base'</p>

                <!-- ################################################################################################ -->
                <h3 id="TRANSCOMM">Le Transistor Bipolaire en commutation</h3>
                <img src="IMAGES/EN_COM_Trans.jpg" alt="">
                <p>Le collecteur et l'émetteur constituent les extrémités du commutateur. La base constitue la borne de
                    commande</p>
                <p>Nous allons nous baser sur le circuit ci-dessous pour voir ce qui se passe :</p>
                <img src="IMAGES/EN_COM_TrCircuit.jpg" alt="">
                <ul>
                    <li>Le circuit de base constitue le circuit de commande. C'est la tension \(V_{bb}\)
                        qui va définir si le transistor se comporte comme un interrupteur <b>ouvert</b> ou <b>fermé</b>
                    </li>
                    <li>La clé du transistor est sa jonction Base_Émetteur (Diode). Si elle est bloquée, le transistor
                        est bloqué. Si elle passante, le transistor est passant.</li>
                    <li>Un transistor <b>bloqué</b> est équivalent à un <b>interrupteur ouvert</b>.</li>
                    <li>Un transistor <b>passant</b> <em>n'est pas forcément</em> équivalent à un <b>interrupteur
                            fermé</b>. Il peut être soit dans le mode <b>linéaire</b> soit dans le mode <b>saturé</b>.
                        C'est ce dernier mode qui correspond à un interrupteur fermé.
                    </li>
                </ul><br>

                <h4>État Bloqué :</h4>
                <ul>
                    <li>Si \(V_{bb} \lt 0.6V\) , La jonction B-E est <b>bloquée</b>,</li>
                    <li>&rArr; Ib=0, Ic=0, &rArr; Transistor <b>Bloqué</b>,</li>
                    <li>&rArr; équivalent à un interrupteur ouvert</li>
                    <li>&rArr; \( V_s = V_{cc} \)</li>
                </ul><br>

                <h4>État Passant :</h4>
                <ul>
                    <li>Si \(V_{bb} \ge 0.7V\) , La jonction B-E est <b>passante</b>, \( V_{BE}=0.7V \)</li>
                    <li>&rArr; Ib &ne; 0, Ic &ne; 0, &rArr; Transistor <b>Passant</b>, \( I_B = \frac{V_{bb}-0.7}{R_b}
                        \)</li>
                    <li>&rArr; Le transistor est passant, il faut vérifier qu'il est dans le mode saturé</li>
                    <li>Pour ça, il faut comparer le courant \(I_B\) avec le seuil de saturation \(
                        I_{Bsat}=\frac{I_{Cmax}}{\beta} \) avec \( \left( I_{Cmax}=\frac{V_{cc}-0.2}{R_c} \right) \)
                        <ul>
                            <li>Si \( I_B \lt I_{Bsat} \) &rArr; Mode <b>Linéaire</b>, \( I_C = \beta I_B \) , \( V_{CE}
                                = V_{cc}-R_c I_C \)</li>
                            <li>Si \( I_B \ge I_{Bsat} \) &rArr; Mode <b>Saturé</b> &rArr; équivalent à un interrupteur
                                fermé : <br>
                                <span class="encadre">
                                    \( V_{CE}=V_{CEsat}=0.2V \) <br>
                                    \( I_C = I_{Cmax}=\frac{V_{cc}-0.2}{R_c} \)</span>
                            </li>
                        </ul>
                    </li>
                </ul> <br>

                <h4>En résumé :</h4>
                <p class="encadre">Pour saturer un transistor, il faut lui appliquer un courant \(I_B\) qui vérifie :
                    $$ I_B \gt I_{Bsat} $$
                    avec :
                    $$ I_{Bsat}=\frac{I_{Cmax}}{\beta} \quad,\quad I_{Cmax}=\frac{V_{cc}-0.2}{R_c} $$
                </p><br>

                <h3>Exemple 1 :</h3>
                <img src="IMAGES/EN_COM_Tr_EX1.jpg" alt="">
                <ol>
                    <li>Donner l'état du transistor et calculer la valeur de Vs dans les deux cas suivants :
                        <ul>
                            <li>Ve = 0V</li>
                            <li>Ve = 5V</li>
                        </ul>
                    </li>
                    <li>Quelle est la fonction logique de ce montage</li>
                </ol><br>

                <h4>Solution :</h4>
                <ul>
                    <li><b>Ve = 0V</b> &rArr; Transistor bloqué &rArr; <b>Vs=5V</b></li>
                    <li><b>Ve=5V</b> &rArr; Transistor passant, <br>
                        Ib = (5-0.7)/10k = 0,43mA <br>
                        Icmax = (5 - 0.2)/1k = 4.8 mA <br>
                        Ibsat = Icmax / 130 = 0.037 mA <br>
                        Ib &gt; Ibsat &rArr; Transistor <b>saturé</b> &rArr; <b>Vs=0.2V</b>
                    </li>
                    <li>Ce montage est un inverseur <img class="inline" src="IMAGES/EN_COM_Inv.jpg" alt=""></li>
                </ul><br>

                <h3>Exemple 2 :</h3>
                <img src="IMAGES/EN_COM_Tr_Ex2.jpg" alt="">
                <p>Calculer Rb pour que le transistor soit saturé avec un facteur de saturation Fs = Ib / Ibsat = 2 </p>
                <h4>Solution :</h4>
                <p>Ibsat = Icmax / 130 = 0.037 mA &rArr; Ib = 2 &times; Ibsat = 0.074mA <br>
                    Rb = (5 - 0.7) / 0.074 k&ohm; = 58 k&ohm;
                </p><br>

                <h3>Exemple 3 :</h3>
                <img src="IMAGES/EN_COM_Tr_Ex3.jpg" alt="">
                <p>Analyser le montage et donner la valeur de Vs dans les cas suivants :</p>
                <ol>
                    <li>Ve = 1V</li>
                    <li>Ve = 2.6V</li>
                    <li>Ve = 5V</li>
                </ol>

                <h4>Solution :</h4>
                <p>On commence par remplacer R1 et R2 par leur équivalent <a target="_blank"
                        href="ElecBase.html#THEVENIN">Thévenin</a> pour obtenir un montage plus familier :</p>
                <img src="IMAGES/EN_COM_Tr_Ex3_Eqv.jpg" alt="">
                <p>Req = R1 // R2 = 1.43 k&ohm; , Veq = ( R2 / (R1 + R2) ) Ve</p>
                <ol>
                    <li>Ve = 1V &rArr; Veq = 0.28V &lt; 0.7V &rArr; transistor <b>bloqué</b> &rArr; <b>Vs = 5V</b></li>
                    <li>Ve = 2.6V &rArr; Veq = 0.74V &gt; 0.7V &rArr; Transistor passant, <br>
                        Ib = (Veq - 0.7)/Req = 0.03mA <br>
                        Icmax = 4.8mA , Ibsat = 0.048mA <br>
                        Ib &lt; Ibsat &rArr; Transistor <b>linéaire</b> &rArr; Ic = &beta;Ib = 3mA <br>
                        <b>Vs = Vcc - Rc Ic = 2V</b>
                    </li>
                    <li>
                        Ve = 5V &rArr; Veq = 1,43V &gt; 0.7V &rArr; Transistor passant, <br>
                        Ib = (Veq - 0.7)/Req = 0.51mA <br>
                        Ib &gt; Ibsat &rArr; Transistor <b>Saturé</b> &rArr; <b>Vs = 0.2V</b>
                    </li>
                </ol> <br>

                <h3>Exemple 4 :</h3>
                <img src="IMAGES/EN_COM_Tr_Ex4.jpg" alt="">
                <p>Analyser le montage, Compléter le tableau, Donner la fonction logique du montage </p><br>
                <h4>Solution :</h4>
                <ul>
                    <li>Si une des des deux entrée = 0V &rArr; Diode correspondante passante &rArr; Vx = 0,7V :
                        Insuffisant pour faire conduire D3 et la Jonction<sub>B-E</sub> en série &rArr; Transistor
                        bloqué &rArr; <b>Vs=5V</b></li>
                    <li>A=5V, B= 5V &rArr; D1 et D2 bloquées (&equiv;absentes) <br>
                        &rArr; (D3 et T) voient 3,6k reliée à 5V
                        &rArr; D3 et T conduisent &rArr; Vx = 2 &times;0.7V = 1,4V <br>
                        Ib = (5-1.4)/3.6k = 1 mA <br>
                        Icmax = (5 - 0.2) / 0.096 k = 50 mA <br>
                        Ibsat = Icmax / &beta; = 0.5 mA <br>
                        Ib &gt; Ibsat &rArr; Transistor <b>Saturé</b> &rArr; <b>Vs = 0.2V</b>
                    </li>
                </ul>
                <img src="IMAGES/EN_COM_Tr_Ex4_Tab.jpg" alt="">
                <p>Pour établir une table logique à partir de cette table électrique, on va adopter le barème suivants :
                <ul>
                    <li>Aux niveaux de <b>tension faibles</b> [0V, 1V] , on fait correspondre le <b>niveau logique 0</b>
                    </li>
                    <li>Aux niveaux de <b>tension forts</b> [4V, 5V] , on fait correspondre le <b>niveau logique 1</b>
                    </li>
                </ul>
                </p>
                <p>on obtient la table ci-dessous qui correspond à une porte NAND :</p>
                <img src="IMAGES/EN_COM_Tr_Ex4_TabL.jpg" alt=""> <br>

                <h3>Exemple 5 :</h3>
                <img src="IMAGES/EN_COM_Tr_Ex5.jpg" alt="">
                <p>Analyser le montage, Compléter le tableau, Donner la fonction logique du montage </p><br>

                <h4>Solution :</h4>
                <ul>
                    <li><b>A=0V, B= 0V :</b>D1a: passante, Va1=0.7V, T1: Bloqué, D2a: passante, Va2=0.7V, T2: Bloqué,
                        \(V_s=5V\) </li>

                    <li><b>A=0V, B= 5V :</b>D1a: passante, Va1=0.7V, T1: Bloqué, D2a: Bloquée, T2: Passant : <br>
                        Ib = (5-1.4)/47k = 76.6 µA <br>
                        Icmax = (5 - 0.2) / 1k = 4.8 mA <br>
                        Ibsat = Icmax / &beta; = 36.9 µA <br>
                        Ib &gt; Ibsat &rArr; Transistor <b>Saturé</b> &rArr; <b>Vs = 0.2V</b>
                    </li>

                    <li><b>A=5V, B= 0V :</b> Idem cas précédent car montage symétrique, <b>Vs = 0.2V</b></li>

                    <li><b>A=5V, B=5V :</b>D1a: Bloquée, T1: Passant, D2a: Bloquée, T2: Passant : <br>
                        Ib1 = Ib2 = (5-1.4)/47k = 76.6 µA <br>
                        IRcmax = (5 - 0.2) / 1k = 4.8 mA <br>
                        Ic1max = Ic2max = IRcmax/2 = 2.4mA <br>
                        Ib1sat = Ib2sat = 2.4mA / &beta; = 18,46 µA <br>
                        Les deux transistors Saturés, <b>Vs = 0.2V</b>
                    </li>
                </ul>
                <img src="IMAGES/EN_COM_Tr_Ex5_Tab.jpg" alt="">
                <p>En utilisant les mêmes niveaux logiques que l'exemple précédent, on obtient la table ci-dessous qui
                    correspond à une porte NOR :</p>
                <img src="IMAGES/EN_COM_Tr_Ex5_TabL.jpg" alt=""> <br>

                <!-- ################################################################################################ -->
                <h2 id="TRANSMOS">Le Transistor MOS en commutation</h2>
                <p>Un transistor MOS ou MOSFET est un type de transistor à effet de champ (MOSFET -
                    Metal-Oxide-Semiconductor
                    Field-Effect Transistor) qui utilise un champ électrique pour contrôler la conductance entre deux de
                    ses terminaux. Il comporte trois principales électrodes :</p>

                <p>Il est constitué de :</p>
                <ul>
                    <li>Une grille métallique accessible par l'électrode G (Grille) qui contrôle la conductance entre le
                        drain et la source via un champ électrique,</li>
                    <li>Un isolant en oxyde de silicium qui isole la grille du reste,</li>
                    <li>Un substrat (Bulk) en silicium (dopé P pour le transistor type N). Sur les cotés du substrat P,
                        on trouve deux zones N sur lesquelles on connecte les électrode D (Drain) et S (Source)</li>
                    <li>La grille est complètement isolée, le courant de grille est toujours nul, la commande se fait en
                        tensions. S'il y a un courant, il aura lieu entre le Drain et la source.
                    </li><br>
                </ul><img src="IMAGES/EN_COM_MOS_NP.jpg" alt=""><br>

                <h3>Catégories de MOSFET :</h3>
                <p>Les MOSFETs se classent en deux Catégories :</p>
                <ul>
                    <li><b>MOS à enrichissement <i>(Enhancement)</i> </b>: Normalement éteint (pas de conduction au
                        repos), nécessite une tension sur la Grille pour créer un canal de conduction entre le Drain et
                        la source</li>
                    <li><b>MOS à appauvrissement <i>(Depletion)</i> </b>: Normalement allumé (conducteur au repos),
                        nécessite une tension sur la Grille pour éliminer le canal de conduction entre le Drain et
                        la source</li>
                    <li>Pour chacune de ces deux Catégories (enrichissement ou appauvrissement), on distingue deux types
                        de transistors :
                        <ul>
                            <li>Canal N, La conduction entre le Drain et la source se fait à travers un canal
                                d'électrons</li>
                            <li>Canal P, La conduction entre le Drain et la source se fait à travers un canal de trous
                            </li>
                        </ul>
                    </li>
                </ul>
                <br>

                <h3>Polarisation du MOS :</h3>
                <p><b>Si on applique une tension Vdd entre le drain est la source, il ne se passe rien</b>, car il n'y a
                    pas de canal de conduction être les deux. Les frontières entre les zones N et le substrat P
                    constituent des jonction PN, quelque soit le sens de la tension Vdd, une des deux jonctions sera
                    polarisée en inverse</p>
                <img src="IMAGES/EN_COM_MOS_DSP.jpg" alt="" class="w500"><br>

                <p>Si on en plus, on applique une tension Vgb entre la grille et le substrat, el va générer un champ
                    dans le substrat qui attire les électrons minoritaires et les accumule contre l'oxyde de silicium.
                    cette accumulation d'électrons crée un canal de conduction entre le drain et la source. La largeur
                    du canal (donc sa résistance) dépend de la valeur de Vgb. Dès lors, le courant Id qui va circuler
                    entre le drain et la source dépend des deux tensions Vds et Vgb
                </p>
                <img src="IMAGES/EN_COM_MOS_POL.jpg" alt="" class="w500"><br> <br>
                <p>J'ai essayé de résumer cela sur l'animation ci dessous, ça vaut ce que ça vaut😊</p>

                <video controls src="IMAGES/EN_COM_MOS_anim.mp4" width="600" class="BlocCenter"></video> <br>

                <h3>Caractéristique de commande :</h3>
                <p>Les caractéristiques ci-dessous montrent la variation du courant Id en fonction de Vgb pour une
                    Tension Vdd constante</p>
                <img src="IMAGES/EN_COM_MOS_CT.jpg" alt="">
                <ul>
                    <li>Pour qu'il y ait création de canal, il faut que Vgb soit supérieure (en valeur absolue) à une
                        tension de seuil (Threshold) Vth</li>
                    <li>Vth dépend des paramètres physiques du transistor. Le plus souvent |Vth| se situe dans
                        l'intervalle [1V , 2V]</li>
                    <li>En commutation, on choisira toujours une tension bien supérieur à Vth pour faire conduire le
                        transistor</li>
                </ul><br>

                <h3>Transistor MOS en commutation</h3>
                <img src="IMAGES/EN_COM_MOS_COM.jpg" alt=""><br>

                <h3>Aspects pratiques :</h3>
                <ul>
                    <li>Normalement, la flèche sur la borne B permet de différentier le canal n du canal p. On peut
                        ajouter un petit rond sur la grille du canal p pour rappeler qu'il faut une tension négative
                        pour le faire conduire,
                        <img src="IMAGES/EN_COM_MOS_ConvD.jpg" alt="">
                    </li>
                    <li>Très souvent, les transistor MOS ne disposent que de trois broches (G, D, S). La borne B est
                        reliée en interne à la borne S. Dans ce cas <b>Vgb = Vgs</b>
                        <img src="IMAGES/EN_COM_MOS_BS.jpg" alt="">
                    </li>
                </ul><br>

                <h3>Inverseur à MOS</h3>
                <img src="IMAGES/EN_COM_MOS_Ex1.jpg" alt="">
                <ul>
                    <li>Analyser le montage et donner la valeur de Vs dans les deux cas suivants :
                        <ul>
                            <li>a) Ve = 0V</li>
                            <li>b) Ve = 5V</li>
                        </ul>
                    </li>
                    <li>Quelle est la fonction logique de ce montage</li>
                </ul><br>
                <h4>Solution :</h4>
                <p>Commençons par rappeler les condition de conduction :</p>
                <img src="IMAGES/EN_COM_MOS_Ex1_Rap.jpg" alt=""><br>
                <p>a) Ve = 0V :</p>
                <img src="IMAGES/EN_COM_MOS_Ex1_a.jpg" alt=""><br>

                <p>b) Ve = 5V :</p>
                <img src="IMAGES/EN_COM_MOS_Ex1_b.jpg" alt="">

                <p>Fonction logique :</p>
                <img src="IMAGES/EN_COM_MOS_Ex1_Fonc.jpg" alt=""><br>

                <h3 id="4011">Porte NAND</h3>
                <img src="IMAGES/EN_COM_MOS_NAND.jpg" alt="">
                <ol>
                    <li>A = 0V, B = 0V,<img src="IMAGES/EN_COM_MOS_NAND_1.jpg" alt=""></li>
                    <li>A = 0V, B = 5V,<img src="IMAGES/EN_COM_MOS_NAND_2.jpg" alt=""></li>
                    <li>A = 5V, B = 0V,<img src="IMAGES/EN_COM_MOS_NAND_3.jpg" alt=""></li>
                    <li>A = 5V, B = 5V,<img src="IMAGES/EN_COM_MOS_NAND_4.jpg" alt=""></li>
                </ol>
                <p>C'est une porte NAND :</p>
                <p class="InlineCenter">
                    <img src="IMAGES/EN_COM_NAND_Table.jpg" alt="" class="inline">
                    <img src="IMAGES/EN_COM_NAND.jpg" alt="" class="inline">
                </p><br>

                <h3 id="4001">Porte NOR</h3>
                <img src="IMAGES/EN_COM_MOS_NOR.jpg" alt="">
                <ol>
                    <li>A = 0V, B = 0V,<img src="IMAGES/EN_COM_MOS_NOR_1.jpg" alt=""></li>
                    <li>A = 0V, B = 5V,<img src="IMAGES/EN_COM_MOS_NOR_2.jpg" alt=""></li>
                    <li>A = 5V, B = 0V,<img src="IMAGES/EN_COM_MOS_NOR_3.jpg" alt=""></li>
                    <li>A = 5V, B = 5V,<img src="IMAGES/EN_COM_MOS_NOR_4.jpg" alt=""></li>
                </ol>
                <p>C'est une porte NOR :</p>
                <p class="InlineCenter">
                    <img src="IMAGES/EN_COM_NOR_Table.jpg" alt="" class="inline">
                    <img src="IMAGES/EN_COM_NOR.jpg" alt="" class="inline">
                </p><br>

                <!-- ################################################################################################ -->
                <h2 id="FAMCIRLOGIC">Familles des circuits logiques</h2>
                <p>Une famille logique regroupe des circuits intégrés aux caractéristiques similaires (entrées,
                    sorties, circuits internes), mais réalisant des fonctions logiques variées. Ces circuits peuvent
                    être interconnectés entre eux, mais leur compatibilité avec d'autres familles peut être impossible
                    ou limitée en raison de différences de tensions d'alimentation ou de conditions d'entrée/sortie.</p>
                <p>La logique bipolaire la plus réussie est le <em>TTL</em> <i>(Transistor-Transistor Logic)</i>,
                    introduite dans les années 1960. Cette famille regroupe plusieurs sous-familles compatibles entre
                    elles, mais différant en vitesse, consommation d'énergie et coût.
                </p>

                <p> Le transistor MOS (MOSFET), inventé avant le transistor bipolaire, n'a été utilisable dans des
                    circuits logiques qu'à partir des années 1960. Malgré une vitesse
                    inférieure, il était prisé pour sa faible consommation d'énergie et son haut niveau d'intégration.
                </p>

                <p>Dès les années 1980, les circuits <em>CMOS</em> <i>(Complementary MOS)</i> ont surpassé les
                    performances des circuits bipolaires,
                    devenant majoritaires pour les circuits intégrés, notamment les microprocesseurs et mémoires.
                    Aujourd'hui, le CMOS domine le marché grâce à sa rapidité, sa faible consommation et son
                    adaptabilité. Malgré cette avance, le TTL reste courant dans les laboratoires académiques.</p>

                <!-- ################################################################################################ -->
                <h3 id="NAMING">Nomenclature commerciale :</h3>
                <p>La nomenclature commerciale doit permettre (facilement) d'identifier le circuit ainsi que sa famille
                    et sous famille.
                    Les constructeurs de circuit logiques ont finalement adopté une nomenclature standard unifiée.</p>
                <p>Le standard spécifie plusieurs champs constituant la reference d'un circuit intégré. Toutefois, les
                    constructeurs ne gravent sur le circuit que les champs les plus importants. Par exemple les champs
                    1,
                    2, 3, 7 et 8</p>
                <img src="IMAGES/EN_FAM_NOM.jpg" alt="">
                <ul>
                    <li><b>Champ 1 :</b> Préfixe indiquant le fabricant ou des spécifications particulières du circuit.
                        Par exemple, <b>SN</b> a été introduit à l'origine par Texas Instruments pour ses circuits
                        logiques TTL sans spécification particulière,</li>
                    <li><b>Champ 2 :</b> Indique s'il s'agit de la série <b>civile</b> ou de la série <b>militaire</b>.
                        C'est surtout
                        la température de fonctionnement qui distingue ces deux séries :
                        <ul>
                            <li><b>74 :</b> Série civile, les spécifications du circuit sont garanties dans la plage de
                                température [0°C,70°C], </li>
                            <li><b>54 :</b> Série militaire, les spécifications du circuit sont garanties dans la plage
                                de
                                température [-55°C,125°C], </li>
                        </ul>
                    </li>
                    <li><b>Champ 3 :</b> <b>Famille</b> du circuit. Par exemple LS correspond à la famille <i>Low Power
                            Schottky</i>
                    </li>
                    <li><b>Champ 7 :</b> <b>Identificateur</b> du circuit. Par exemple 76 est l'identificateur du
                        circuit qui
                        contient deux bascule JK</li>
                    <li><b>Champ 8 :</b> Ce suffixe indique le type de <b>boîtier</b>. Par exemple N correspond au
                        boîtier <i>dual in line
                            plastique.</i> <br>
                        Voici une liste de Suffixe de boîtiers : <br>
                        <img src="IMAGES/EN_FAM_PACK_Sufix.jpg" alt="">
                        Voici quelques types de boîtiers : <br>
                        <img src="IMAGES/EN_FAM_PACK_Type.jpg" alt="">
                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h2 id="TTLFMLY">La famille TTL</h2>
                <p>La famille TTL (Transistor-Transistor Logic) est une technologie de circuits numériques
                    basée sur des transistors bipolaires. Elle a été introduite dans les années 1960 et a rapidement
                    dominé le marché des circuits numériques grâce à sa fiabilité, sa vitesse et sa facilité
                    d'utilisation. Cependant, à partir des années 1980, elle a commencé à décliner face à la famille
                    CMOS, qui offre des performances supérieures, une consommation énergétique réduite et une meilleure
                    intégration.</p><br>

                <!-- ################################################################################################ -->
                <h3 id="TTLCARC">Caractéristiques principales :</h3>
                <ol>
                    <li><b>Structure interne :</b> Les circuits TTL utilisent des <b>transistors bipolaires</b>. Ils
                        intègrent également des résistances et des diodes,</li>
                    <li><b>Tension d'alimentation : </b>La plupart des circuits TTL fonctionnent avec une alimentation
                        standard de <b>5 volts</b>,</li>
                    <li><b>Vitesses de fonctionnement :</b> Les circuits TTL classiques offrent des vitesses moyennes
                        (10 ns), mais différentes sous-familles améliorent cet aspect,</li>
                    <li><b>Consommation d'énergie :</b> Les premières versions de la famille TTL avaient une
                        consommation relativement importante (10 mW). Là aussi, on a développé des sous-familles qui
                        améliorent cet aspect.</li>
                </ol><br>

                <!-- ################################################################################################ -->
                <h3 id="TTLSUBFAM">Sous-familles courantes :</h3>
                <ul>
                    <li><b>Standard () :</b> Première génération, caractérisée par des performances de base (10ns, 10
                        mW),</li>

                    <li><b>Low Power (L) :</b> Réduction de la consommation d'énergie au détriment de la vitesse ,
                        (33ns, 1 mW),</li>
                    <li><b>High Speed (H) :</b> Amélioration de la vitesse au détriment de la consommation , (6ns, 22
                        mW),</li>
                    <li><b>Schottky (S) :</b> Vitesse accrue grâce à l'utilisation de diodes Schottky, mais avec une
                        consommation énergétique plus élevée (3ns, 19 mW),</li>
                    <li><b>Low Power Schottky (LS) :</b> Compromis entre vitesse et consommation énergétique (9.5ns, 2
                        mW), largement utilisée,</li>
                    <li><b>Advanced Schottky (AS) :</b> Version avancée de la famille Schottky (1.5ns, 8 mW),</li>
                    <li><b>Advanced Low Power Schottky (ALS) :</b> Version avancée de la famille Low Power Schottky
                        (4ns, 1 mW).</li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="7400">Le circuit 7400 :</h3>
                <p>Le 7400 est l'un des circuits intégrés les plus célèbres et emblématiques de la famille TTL. Il est
                    souvent considéré comme le point de départ pour l'apprentissage des circuits logiques en raison de
                    sa simplicité et de son importance historique. Il contient quatre portes logiques NAND à deux
                    entrées dans un boîtier standard DIP (Dual Inline Package).
                </p>
                <img src="IMAGES/EN_FAM_7400_Pinout.jpg" alt="">
                <p>le schéma interne des portes NAND est le suivant :</p>
                <img src="IMAGES/EN_FAM_7400_Sch.jpg" alt="">
                <ul>
                    <li>Le transistor Q1 qui constitue l'étage d'entrée ne fonctionne pas comme un transistor mais comme
                        3 diodes. Nous avons rencontré quelques chose de similaire dans L'exemple 4 du <a
                            target="_blank" href="Elec_Num.html#TRANSCOMM">transistor bipolaire en commutation,</a>
                        <img src="IMAGES/EN_FAM_7400_Input.jpg" alt="">
                    </li>
                    <li>L'état du transistor Q2 dépend des états des deux entrées. Dans ses états bloqué ou saturé, il
                        va
                        activer soit le transistor Q3, soit le transistor Q4. Entre les deux (pendant la transition), il
                        fonctionne en amplificateur pour accélérer les variations d'entrée est obtenir une
                        transition plus abrupte.
                    </li>
                    <li>Les transistors Q3 et Q4 ainsi que la diode D3 constituent l'étage de sortie de la porte. Q3 et
                        D3 jouent le rôle du du commutateur K1 <b>(pull-up)</b> qui relie la sortie au nivaux haut. Q4
                        constitue le commutateur K2 <b>(pull-down)</b> qui relie la sortie au nivaux bas. La diode D3 a
                        été ajoutée pour s'assurer que les deux commutateurs ne conduisent pas simultanément. Cet étage
                        porte le nom de <i>Totem-pole</i>
                        <img src="IMAGES/EN_FAM_7400_Output.jpg" alt="">
                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="CARTRANS">Caractéristique de transfert :</h3>
                <p>Pour tracer la caractéristique de transfert on fait varier les deux entrées (reliées) entre 0V et 5V
                    et on relève les valeurs de la tension de sortie. On peut aussi connecter une des entrée au niveau
                    haut et faire varier l'autre entrée. Dans les deux cas, ça revient à tracer la caractéristique d'un
                    inverseur. On obtient une caractéristique similaire à :</p>
                <img src="IMAGES/EN_FAM_CAR_TRANS.jpg" alt="">




                <!-- ################################################################################################ -->
                <h3 id="NIVLOGIC">Niveaux logiques :</h3>
                <p>Si l'on trace la caractéristique de transfert de différentes portes NAND 7400 provenant de
                    constructeurs différents, fonctionnant à des températures variées ou avec des charges TTL
                    différentes, on n'obtient pas exactement la même courbe. On observe une dispersion dans les valeurs
                    des niveaux logiques haut et bas, ainsi que dans la tension de transition.

                    Cette dispersion est due aux variations inhérentes aux procédés de fabrication, aux tolérances des
                    composants internes, et aux conditions de fonctionnement, telles que la température ou la charge
                    connectée à la sortie. Malgré ces variations, les circuits TTL sont conçus pour garantir une
                    compatibilité entre les composants en définissant des plages de tensions qui font que les niveaux
                    logique en sortie soient compatibles avec les niveaux logiques en entrée
                </p><br>

                <h4>Niveaux logiques à l'entrée</h4>
                <p>Si on considère la figure ci-dessous qui montre une dispersion <i>(un peu exagérée)</i> de la
                    caractéristique de transfert</p>
                <img src="IMAGES/EN_FAM_CAR_TR_INP.jpg" alt="">
                <ul>
                    <li>Le <b>Niveau bas à l'entrée </b> est le niveau qui génère un niveau haut en sortie. D'après la
                        figure, toute tension d'entrée inférieure ou égale à 0.8V vérifie cette condition. Par
                        conséquent : <br>
                        L'intervalle <em>[0V, 0.8V]</em> constitue le <em>niveau bas à l'entrée</em> de la famille TTL.
                        La valeur 0.8V est la limite supérieure de cet intervalle, on l'appelle \(V_{ILmax}\)
                        <i>(Input Low max voltage)</i>
                    </li>
                    <li>Le <b>Niveau haut à l'entrée </b> est le niveau qui génère un niveau bas en sortie. D'après la
                        figure, toute tension d'entrée supérieure à 2V vérifie cette condition. Par conséquent : <br>
                        L'intervalle <em>[2V, 5V]</em> constitue le <em>niveau haut à l'entrée</em> de la famille TTL.
                        La valeur 2V est la limite inférieure de cet intervalle, on l'appelle \(V_{IHmin}\)
                        <i>(Input High min voltage)</i>
                    </li>
                </ul><br>

                <h4>Niveaux logiques à la sortie</h4>
                <p>Si on considère la figure ci-dessous qui montre une dispersion <i>(un peu exagérée)</i> de la
                    caractéristique de transfert</p>
                <img src="IMAGES/EN_FAM_CAR_TR_OUT.jpg" alt="">
                <p>Les niveaux logiques à la sortie sont définis de manière à garantir la compatibilité avec les niveaux
                    d'entrée tout en maintenant une marge de sécurité suffisante pour éviter les erreurs de
                    fonctionnement :</p>
                <ul>
                    <li>L'intervalle <em>[0V, 0.4V]</em> constitue le <em>niveau bas en sortie</em> de la famille TTL.
                        La valeur 0.4V est la limite supérieure de cet intervalle, on l'appelle \(V_{OLmax}\)
                        <i>(Output Low max voltage)</i>
                    </li>
                    <li>L'intervalle <em>[2.4V, 5V]</em> constitue le <em>niveau haut en sortie</em> de la famille TTL.
                        La valeur 2.4V est la limite inférieure de cet intervalle, on l'appelle \(V_{OHmin}\)
                        <i>(Output High min voltage)</i>
                    </li>
                </ul><br>

                <h4>Illustration :</h4>
                <img src="IMAGES/EN_FAM_NIVTTL.jpg" alt="">
                <ul>
                    <li>C'est nous qui décidons quoi brancher à l'entrée d'une porte. Dès lors, les niveaux de tension
                        en
                        entrée sont des niveaux recommandés que nous devons respecter,</li>
                    <li>C'est la porte qui génère les tensions de sortie. Donc, les niveaux de sortie sont garantis par
                        le constructeur, à condition que la charge connectée respecte les limitations de courant que
                        nous verrons plus bas.</li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="MARGEBRUIT">Immunité au bruit</h3>
                <p>L'immunité au bruit, également appelée marge de bruit (noise margin), est une caractéristique
                    importante de la famille TTL (Transistor-Transistor Logic) et des circuits numériques en général.
                    Elle représente la capacité d'un circuit logique à tolérer des perturbations (bruit électrique) sans
                    altérer les niveaux logiques corrects. Voici une explication détaillée :</p>
                <img src="IMAGES/EN_FAM_NM.jpg" alt=""><br>
                <p>La marge de bruit est définie comme la différence entre Les niveaux garantis à la sortie Les niveaux
                    requis à l'entrée.</p>
                <ul>
                    <li><b>Marge de bruit niveau bas :</b> \( MB_L = V_{ILmax}-V_{OLmax}=0.8V - 0.4V = 0.4V \)</li>
                    <li><b>Marge de bruit niveau haut :</b> \( MB_H = V_{OLmin}-V_{ILmin}=2.4V - 2V = 0.4V \)</li>
                </ul>
                <p>En conclusion, <b>la marge de bruit de la famille TTL standard est typiquement 0.4V</b> pour les deux
                    niveaux logiques (haut et bas).
                    Cela signifie que si une perturbation ou un bruit électronique introduit une variation de tension de
                    ±0.4V autour
                    des niveaux de sortie garantis, le circuit continuera à fonctionner correctement.
                </p>
                <img src="IMAGES/EN_FAM_NM2.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="IINPUTMAX">Les courants d'entrée maximums</h3>
                <p>Quand on applique une tension basse ou une tension haute à l'entrée d'une porte, La datasheet précise
                    les valeur max des courants qui vont circuler dans l'entrée</p>
                <img src="IMAGES/EN_FAM_INP_CURR.jpg" alt="">
                <ul>
                    <li>\(I_{ILmax}\) <i>(Input Low max)</i> : Quant on applique un <b>niveau bas</b> à l'entrée, le
                        constructeur garantit que le courant \(I_{IL}\) qui en résulte ne dépassera pas la valeur
                        maximum
                        \(I_{ILmax}=1.6mA\). Dans la datasheet, il est est indiqué comme négatif car il sort de la
                        porte.
                    </li>
                    <li>\(I_{IHmax}\) <i>(Input High max)</i> : Quant on applique un <b>niveau haut</b> à l'entrée, le
                        constructeur garantit que le courant \(I_{IH}\) qui en résulte ne dépassera pas la valeur
                        maximum
                        \(I_{IHmax}=40µA\). Dans la datasheet, il est est indiqué comme positif car il entre dans la
                        porte.
                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="IOUTUTMAX">Les courants de sortie maximums</h3>
                <p>Le courant de sortie d'une porte dépend de la charge connectée. Or, Le niveaux de la tension de
                    sortie dépend de la valeur du courant de sortie. Lorsque le courant de sortie augmente, le
                    niveaux de la tension de sortie se dégrade et peut sortir des intervalles normalisés. Il est donc
                    recommandé de ne pas connecter des charges nécessitant un courant trop élevé afin de préserver la
                    stabilité des niveaux logiques. </p>
                <p>Les courbes ci-dessous illustrent la variation de la tension de sortie en fonction du courant de
                    sortie,</p>
                <img src="IMAGES/EN_FAM_VoIo.jpg" alt=""><br>

                <ul>
                    <li>\(I_{OHmax}\) <i>(Output High max)</i> : Quand on connecte une charge à une sortie au <b>niveau
                            haut</b>, la valeur \(I_{OH}\) du courant de sortie fourni par la porte dépend de la valeur
                        de la
                        charge. Il est recommandé de faire de sorte que \(I_{OH}\) ne dépasse pas la valeur max
                        \(I_{OHmax}=0.4mA\) pour garantir que la tension de sortie \( V_{OH} \) reste supérieure à 2.4V
                    </li>
                    <li>\(I_{OLmax}\) <i>(Output Low max)</i> : Quand on connecte une charge à une sortie au <b>niveau
                            bas</b>, la valeur \(I_{OL}\) du courant de sortie (injecté) dans la porte dépend de la
                        valeur de la
                        charge. Il est recommandé de faire de sorte que \(I_{OL}\) ne dépasse pas la valeur max
                        \(I_{OLmax}=16mA\) pour garantir que la tension de sortie \( V_{OL} \) reste inférieure à 0.4V
                    </li>
                </ul>
                <img src="IMAGES/EN_FAM_OUTCURR.jpg" alt="">
                <h4>En résumé :</h4>
                <img src="IMAGES/EN_FAM_TTL_Niveaux.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="SORTANCE">Sortance :</h3>
                <p>La Sortance <i>(fan-out en anglais)</i> représente le nombre maximum de portes logiques que l'on peut
                    connecter à la
                    sortie d'une porte logique sans altérer significativement les niveaux logiques standardisés.
                    Elle dépend directement des caractéristiques électriques des circuits, en particulier, les courants
                    Iilmax, IiHmax, Iolmax, Iohmax.</p>
                <p>Lorsque la sortance est dépassée, cela peut entraîner une dégradation des niveaux logiques, une
                    diminution de la marge de bruit, et un fonctionnement erratique du circuit.</p>
                <h4>Sortance au niveau bas :</h4>
                <img src="IMAGES/EN_FAM_Sortance_Low.jpg" alt="">
                <ul>
                    <li>Le courant max que la sortie d'une porte peut recevoir est \(I_{OLmax}=16mA \)</li>
                    <li>Chaque porte branchée apporte un courant qui peut aveindre \(I_{ILmax}=1.6mA \)</li>
                    $$ Sortance_L = \frac{I_{OLmax}}{I_{ILmax}}= \frac{16mA}{1.6mA} = 10 $$
                </ul><br>

                <h4>Sortance au niveau Haut :</h4>
                <img src="IMAGES/EN_FAM_Sortance_High.jpg" alt="">
                <ul>
                    <li>Le courant max qu'une sortie au niveau haut peut donner est \(I_{OHmax}=0.4mA=400µA \)</li>
                    <li>Chaque porte branchée absorbe un courant qui peut aveindre \(I_{IHmax}=40µA \)</li>
                    $$ Sortance_H = \frac{I_{OHmax}}{I_{IHmax}}= \frac{400µA}{40µA} = 10 $$
                </ul>
                <p>Donc pour la famille TTL standard, la sortance est la même pour ls niveaux haut et bas :</p>
                <p class="InlineCenter"><span class="encadre">$$ Sortance = 10 $$</span></p>

                <!-- ################################################################################################ -->
                <h3 id="PUISSANCE">Puissance consommée :</h3>
                <img src="IMAGES/EN_FAM_Icc.jpg" alt="" class="Float_R">
                <p>Une porte logique ne consomme pas le même courant quand sa sortie est au niveau haut et au niveau
                    bas. Pour donner une valeur typique de la consommation, on prend la moyenne</p>
                <p>\( I_{CCHtyp}=1mA \) , \( I_{CCLtyp}=3mA \) &rArr; \( I_{CCtyp}=\frac{1mA+3mA}{2}=2mA \)</p>
                <p>La puissance typique consommée est :</p>
                <p class="InlineCenter"><span class="encadre">$$ P_{typ} = V_{cc} \times I_{cctyp} = 5V \times 2mA = 10
                        mW $$</span></p>
                <p>La consommation augmente légèrement avec la fréquence. On peut considérer la valeur de 10 mW valable
                    jusqu'à une fréquence de 1 MHz</p><br>

                <!-- ################################################################################################ -->
                <h3 id="TP">Temps de propagation</h3>
                <p>Le temps de propagation correspond au délai entre l'application dun changement d'état sur l'entrée
                    d'une porte logique et l'apparition de la réponse correspondante sur sa sortie.</p>
                <img src="IMAGES/EN_FAM_Tp.jpg" alt="">
                <ul>
                    <li><b>\( T_{PHL} \) : </b>Temps de propagation pour un passage de l'état haut à l'état bas,</li>
                    <li><b>\( T_{PLH} \) : </b>Temps de propagation pour un passage de l'état bas à l'état haut,</li>
                </ul>
                <p>Pour la famille TTL standard :</p>
                <p>\( T_{PHLtyp}= 8ns ~~~\) , \( T_{PLHtyp}= 12ns \)</p>
                <p class="InlineCenter"> <span class="encadre">$$ T_{Ptyp}= 10ns $$</span> </p>

                <!-- ################################################################################################ -->
                <h3 id="MAXFREQ">Fréquence maximale d'utilisation</h3>
                $$ f_{max}= \frac{1}{T_{PHLtyp}+T_{PLHtyp}} = \frac{1}{20ns}=50 MHz $$
                <p>Pour garantir un bon fonction d'un système basé sur des circuits TTL standard, il est conseillé de se
                    limiter à :</p>
                <p class="InlineCenter"> <span class="encadre">$$ f_{max}= 40 Mhz $$</span> </p>

                <!-- ################################################################################################ -->
                <h3 id="OPENCOL">Sortie collecteur ouvert</h3>
                <img src="IMAGES/EN_FAM_CO.jpg" alt="">
                <p>Dans une porte avec sortie collecteur ouvert <i>(Open Collector)</i>, le commutateur qui permet de
                    placer la sortie au niveau haut a été supprimé. La sortie est connecté au collecteur du transistor
                    restant (Q4 dans notre exemple) d'où le nom de collecteur ouvert</p>
                <ul>
                    <li>Lorsque le transistor est saturé (ON), la sortie est connectée à la masse (0V), ce qui
                        correspond à un niveau bas, </li>
                    <li>Lorsque le transistor est bloqué (OFF), la sortie est "flottante", le niveau haut devra être
                        établi par un circuit externe. </li>
                </ul>
                <p>La méthode la plus courante pour fixer le niveau haut de la sortie est d'utiliser une résistance de
                    pull_up externe. Cette résistance peut être reliée à une tension différente de Vcc ce qui va
                    permettre une grande souplesse d'utilisation</p>
                <img src="IMAGES/EN_FAM_CO_PU.jpg" alt="">
                <p>Les portes collecteur Ouvert ont différentes applications utiles comme :</p>
                <ol>
                    <li><b>Adaptation de niveau :</b> Permet de piloter une porte non TTL alimentée par une alimentation
                        différente de 5V,
                        <img src="IMAGES/EN_FAM_CO_Adapt.jpg" alt="">
                    </li>
                    <li><b>ET câblé :</b> Plusieurs sorties collecteur ouvert peuvent être connectées ensemble ce qu
                        permet de réaliser une fonction ET <i>gratuitement</i>. Tout le monde s'accorde à dire que c'est
                        un "OU", pour
                        moi, c'est un "ET" 😊.
                        <img src="IMAGES/EN_FAM_CO_ETCable.jpg" alt="">
                        En fait, si on veut être rigoureux, l'appellation OU câblé ou ET câblé dépendent de la logique.
                        En logique positive, vrai=1. En logique négative, vrai=0. Donc pour notre circuit :
                        <ul>
                            <li>La sortie commune est à 1 si les deux sorties sont à 1, ce
                                qui correspond à une fonction ET en logique positive</li>
                            <li>La sortie commune est à 0 si au moins une des deux sortie est à 0, ce
                                qui correspond à une fonction OU en logique négative</li>

                        </ul>
                    </li>
                    <li><b>Piloter une charge haute tension :</b> Si par exemple on veut contrôler une LED 12V, on ne
                        peut pas le
                        faire directement avec une porte TTL normale. Par contre, la porte collecteur ouvert est
                        parfaitement adaptée :
                        <img src="IMAGES/EN_FAM_CO_HT.jpg" alt="">
                    </li>
                </ol><br>

                <!-- ################################################################################################ -->
                <h3 id="TRISTATE">Sortie trois états :</h3>
                <p>Les sorties trois états, également appelées sorties "Tri-State" ou sorties à haute impédance, sont
                    des sorties numériques capables de se trouver dans l'un des trois états suivants :</p>
                <ol>
                    <li>État haut (1) : La sortie délivre une tension correspondant à un niveau logique haut.</li>
                    <li>État bas (0) : La sortie délivre une tension correspondant à un niveau logique bas.</li>
                    <li>État haute impédance (Hi-Z) : La sortie est déconnectée du circuit, se comportant comme une
                        impédance très élevée, équivalente à un circuit ouvert. Dans cet état, la sortie n'influence pas
                        le reste du circuit.</li>
                </ol>
                <p>Cette fonctionnalité est particulièrement utile dans les systèmes où plusieurs dispositifs partagent
                    une même ligne de communication, comme un bus de données. Les sorties trois états permettent à
                    plusieurs circuits de se connecter à une même ligne sans interférer les uns avec les autres, à
                    condition qu'une seule sortie soit active (en état haut ou bas) à la fois, tandis que les autres
                    sont en état haute impédance. Cela évite les conflits de bus et permet une communication
                    bidirectionnelle</p>
                <p>Par exemple, dans un système informatique, les mémoires et les périphériques peuvent partager le même
                    bus de données. Grâce aux sorties trois états, chaque dispositif peut prendre le contrôle du bus
                    lorsqu'il est sélectionné, tandis que les autres se mettent en état haute impédance, évitant ainsi
                    les courts-circuits et les interférences.</p>
                <img src="IMAGES/EN_FAM_HZ.jpg" alt="" class="Float_R">
                <p>En général,les circuit tristate on une entrée de contrôle qui permet de place la sortie en mode haute
                    impédance : </p>
                <ul>
                    <li>HZ = 1 : fonctionnement normal, sortie 2 états</li>
                    <li>HZ = 0 : Sortie haute impédance</li>
                </ul>
                <p>La figures ci dessous montre plusieurs circuit connectés à un bus. Seul le circuit qui est
                    sélectionné pour écrire dans le bus doit être en basse impédance, tous les autres doivent être
                    en haute impédance</p>
                <img src="IMAGES/EN_FAM_HZ_BUS.jpg" alt="">
                <p>Les circuit tri-state sont aussi très utiles pour réaliser des buffer bidirectionnel qui permettent
                    d'utiliser une ligne dans un sens ou dans l'autre. Par exemple dans une mémoire, on utilise le même
                    bus pour lire et pour écrire,</p>
                <img src="IMAGES/EN_FAM_HZ_Buffer.jpg" alt=""><br>


                <!-- ################################################################################################ -->
                <h3 id="S_TRIG">Entrées à trigger de Schmitt</h3>
                <img src="IMAGES/EN_FAM_TS.jpg" alt="">
                <p>Certains circuit logiques sont conçus avec un circuit d'entrée particulier qui fait que la
                    caractéristique de transfert comporte un <b>hystérésis</b> qui définit deux seuils de tension
                    distincts pour les transitions montantes et descendantes</p>
                <p>Voici la caractéristique de transfert d'un inverseur avec entré trigger de Schmitt</p>
                <img src="IMAGES/EN_FAM_TS_CT.jpg" alt="">
                <ul>
                    <li><b>Seuil haut </b>\(V_{th} \) : Lorsque la tension d'entrée <i>Vi</i> est en train d'augmenter,
                        quand elle
                        atteint ce seuil, la sortie <i>Vo</i> bascule de l'état haut à l'état bas,</li>
                    <li><b>Seuil bas </b>\(V_{tl} \) : Lorsque la tension d'entrée <i>Vi</i> est en train de diminuer,
                        quand elle
                        atteint ce seuil, la sortie <i>Vo</i> bascule de l'état bas à l'état haut,</li>
                </ul>
                <h4>Avantages :</h4>
                <ul>
                    <li><b>Rejet du bruit : </b>La différence de seuils empêche les commutations intempestives dues
                        aux variations mineures ou au bruit sur le signal d'entrée, assurant ainsi une sortie stable en
                        évitant les oscillations indésirables de la sortie,
                    </li>
                    <li><b>Amélioration des transitions :</b> Pour obtenir un hystérésis sur la caractéristique de
                        transfert, l'étage d'entrée comporte une <strong>contre réaction positive</strong> dont une des
                        propriété est
                        l'accélération des transition. De ce fait, on va obtenir des transitions de sortie très rapides
                        (verticales) même dans le cas d'une entrée variant très lentement. </li>
                </ul>
                <h4>Applications :</h4>
                <ul>
                    <li><b>Déparasitage de contacts : </b>Élimination des rebonds lors de l'appui sur des boutons ou
                        interrupteurs mécaniques.
                        <img src="IMAGES/EN_FAM_TS_DBcer.jpg" alt="">
                    </li>
                    <li><b>Conditionnement de signaux : </b>Conversion de formes d'onde analogiques en signaux
                        numériques propres.
                        <img src="IMAGES/EN_FAM_TS_MF.jpg" alt="">
                    </li>
                    <li><b>Oscillateurs : </b>Utilisation dans des circuits oscillateurs pour générer des signaux
                        périodiques.
                        <img src="IMAGES/EN_FAM_TS_Osc.jpg" alt="">
                        <img src="IMAGES/EN_FAM_TS_OSC_CRB.jpg" alt="">
                    </li>
                </ul><br>
                <!-- ################################################################################################ -->
                <h3 id="SUBFAM">Spécifications de quelques Sous-familles TTL</h3>
                <img src="IMAGES/EN_FAM_SUBF_SPECS.jpg" alt="">
                <img src="IMAGES/EN_FAM_SUBF_CRB1.jpg" alt="">
                <img src="IMAGES/EN_FAM_SUBF_CRB2.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id="CMOS">La famille CMOS (Complementary MOS)</h2>
                <p>Cette famille tient son nom (Complementary) du fait que chaque étage d'un circuit numérique est
                    constitué de deux transistors MOS complémentaires : un canal N et un canal P</p>
                <p>Les caractéristiques principales de cette famille sont :</p>
                <ul>
                    <li><b>Faible consommation : </b> En fait, c'est la consommation <b>statique</b> (basse fréquences)
                        qui est quasi nulle. Idéal pour les applications alimentées par batterie. La consommation
                        <b>dynamique</b> (haute fréquence) devient similaire aux familles TTL.
                    </li>
                    <li><b>Très bonne Immunité au bruit :</b> Les circuits CMOS ont une bonne marge de bruit grâce à
                        leur large plage de tensions acceptables pour les niveaux logiques</li>
                    <li><b>Souplesse des tensions d'alimentation :</b> Les circuits CMOS peuvent fonctionner avec une
                        large gamme de tensions d'alimentation, typiquement de 3V à 15V. Certaines sous familles sont
                        conçues pour fonctionner avec une alimentation de 1.8V ou 1.2V</li>
                    <li><b>Densité élevée : </b> Les transistors MOS sont très compacts, permettant d'intégrer des
                        millions (voire des milliards) de transistors sur une seule puce.</li>
                    <li><b>Vitesse de fonctionnement élevée :</b> Contrairement aux premiers circuits CMOS (série 4000)
                        qui étaient moins rapides que les circuits TTL, les circuit CMOS modernes offrent des temps de
                        commutation très courts, adaptés aux applications rapides.</li>
                    <li><b>Limitations :</b>
                        <ul>
                            <li>Les transistors MOS sont très sensibles à l'électricité statique. Ils peuvent être
                                endommagés par des décharges électrostatiques (ESD), nécessitant des précautions lors de
                                la manipulation.</li>
                            <li>La consommation peut augmenter significativement à haute fréquence, ce qui engendre une
                                dissipation
                                thermique nécessitant un système de refroidissement.</li>
                            <li>Les circuits CMOS ne peuvent pas fournir de forts courants en sortie sans l'ajout de
                                buffers ou de drivers externes.</li>
                        </ul>
                    </li>
                </ul><br>
                <p>La famille CMOS est constituée de plusieurs sous-familles :</p>
                <ul>
                    <li><b>Série 4000</b> : CMOS standard, première famille développée</li>
                    <li><b>74C : </b>Mêmes spécifications que la série 4000 mais avec la nomenclature normalisée</li>
                    <li><b>74AC : </b>advanced CMOS</li>
                    <li><b>74HC : </b>High-Speed CMOS Logic</li>
                    <li><b>74ACT : </b>advanced CMOS compatible TTL</li>
                    <li><b>74HCT : </b>High-Speed CMOS Logic compatible TTL</li>
                    <li><b>74AHC : </b>Advanced High-Speed CMOS Logic</li>
                    <li><b>74AHCT : </b>Advances High-Speed CMOS Logic compatible TTL</li>
                    <li><b>74BCT : </b>BiCMOS technology</li>
                    <li><b>74ABT : </b>Advanced BiCMOS</li>
                    <li><b>74LV : </b>Low Voltage HCMOS Technology</li>
                    <li><b>74LVC : </b> Low Voltage CMOS</li>
                    <li><b>74ALVC : </b>Advanced Low Voltage CMOS</li>
                    <li><b>74LVT : </b>Low Voltage Technology</li>
                    <li><b>74ALVT : </b>Advanced Low Voltage Technology</li>
                    <li><b>74ALB : </b>Advanced Low voltage BiCMOS</li>
                    <li><b>74CBTLV : </b> Low Voltage Bus Switches (Crossbar technology)</li>
                </ul>


                <!-- ################################################################################################ -->
                <h3 id="CD4000">La série 4000 :</h3>
                <p>La série 4000 est la première famille CMOS. Elle a été introduite dans les années 1970 pour
                    fournir des alternatives plus flexibles et économes en énergie par rapport à la famille TTL. Bien
                    que largement dépassée par les circuits modernes, la série 4000 est encore utilisée dans des
                    applications basse fréquence (&lt; 1MHz) nécessitant une faible consommation
                    d'énergie et une compatibilité avec différentes plages de tensions</p>

                <h4>Tension d'alimentation :</h4>
                <p>Les circuits de la famille 4000 ne sont pas obligatoirement alimentés entre une tension positive fixe
                    et la masse comme c'est le cas de la famille TTL. Ils peuvent être alimentés entre une tension Vdd
                    et une tension Vss quelconques en respectant les limites \( 3V \lt (V_{DD}-V_{SS}) \lt 18V \). Les
                    niveaux logiques haut et bas seront définis ultérieurement avec plus de précision mais on peut déjà
                    dire que \( V_{OH} \approx V_{DD} \) , \( V_{OL} \approx V_{SS} \). <br>
                    Le plus souvent, les circuits sont alimentés par rapport à la masse (Vss=0), ave Vdd = 5V, 10V ou
                    15V
                </p><br>

                <h4>Température de fonctionnement :</h4>
                <ul>
                    <li>[-40 , 85]°C pour la série civile</li>
                    <li>[-55 , 125]°C pour la série militaire.</li>
                </ul><br>

                <h4>Transistors MOS utilisés :</h4>
                <img src="IMAGES/EN_FAM_4K_MOS.jpg" alt="">
                <br>

                <!-- ################################################################################################ -->
                <h3 id="4KINV">Le circuit élémentaire (Inverseur)</h3>
                <img src="IMAGES/EN_FAM_4K_INV.jpg" alt="">
                <ul>
                    <li>\( V_i=0 \;,\; V_{GS1}= -V_{DD} \rightarrow Q_1:ON \;,\quad V_{GS2}= 0 \;\rightarrow\; Q_2:OFF
                        \; \Rightarrow V_o=V_{DD} \)</li>
                    <li>\( V_i=V_{DD} \;,\; V_{GS1}= 0 \rightarrow Q_1:OFF \;,\quad V_{GS2}= V_{DD} \;\rightarrow\;
                        Q_2:ON \; \Rightarrow V_o=0 \)</li>
                </ul>
                <p>Si on fait varier Vi entre 0 et Vdd, on obtient la caractéristique de transfert ci-dessous. Comme le
                    circuit est symétrique, on constate que la tension de transition est égale à Vdd/2</p>
                <img src="IMAGES/EN_FAM_4K_INV_CRB.jpg" alt=""> <br>

                <!-- ################################################################################################ -->
                <h3 id="4KNIVLINP">Niveaux logiques en entrée</h3>
                <img src="IMAGES/EN_FAM_4K_NIVL.jpg" alt="">
                <p>Les niveaux logiques en entrées dépendent de la tension d'alimentation. Les intervalles correspondant
                    au niveau logiques bas et haut sont symétriques et ont la même largeur. L'approximation \( \Delta
                    V_i \approx 30 \% V_{dd} \) colle
                    assez bien aux spécifications des datasheets.
                </p>
                <img src="IMAGES/EN_FAM_4K_NIVL_TAB.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="4KNIVLOUT">Niveaux logique en Sortie</h3>
                <p>Le niveau de la tension de sortie dépend très fortement du courant de sortie. Cette variation est due
                    à la chute
                    de tension dans la résistance \(R_{DSon}\) du transistor passant.</p>
                <img src="IMAGES/EN_FAM_4K_VoIo.jpg" alt="">
                <p>Dans des conditions idéales, une porte CMOS devrait être connectée à l'entrée d'une
                    autre porte CMOS. À cause de l'impédance d'entrée très élevée des circuits CMOS, le courant de
                    sortie de
                    la première porte sera pratiquement nul. Cela permet d'obtenir des niveaux logiques de sortie
                    parfaits :</p>
                <ul>
                    <li>\( V_{OH} = V_{DD}\)</li>
                    <li>\( V_{OL} = 0\)</li>
                </ul><br>

                <h4>En résumé :</h4>
                <img src="IMAGES/EN_FAM_4K_NIVLOG.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="NOISEMARGIN">Marge de bruit :</h3>
                <img src="IMAGES/EN_FAM_4K_NOISE.jpg" alt="">
                <p>La marge de bruit est de l'ordre de \( \Delta V_i \approx 30 \% V_{dd} \), ce qui offre des
                    tolérances très importantes pour les
                    tensions d'alimentation élevées. Cela constitue un des avantages majeurs de cette famille, la
                    rendant quasi incontournable pour des applications dans des environnements fortement parasités,
                    comme au sein d'unités industrielles.</p>

                <img src="IMAGES/EN_FAM_4K_NOISE_Tab.jpg" alt="">
                <p>Cela signifie qu'avec Vdd=15V, on peut avoir des parasites de plus de 4Volts qui se
                    superposent au signaux sans altérer le fonctionnement normal</p>
                <br>

                <!-- ################################################################################################ -->
                <h3 id="SORTANCE4K">Sortance :</h3>
                <p>La Sortance (fan-out en anglais) représente le nombre maximum de portes logiques que l'on peut
                    connecter à la sortie d'une porte logique sans altérer significativement les niveaux logiques
                    standardisés.</p>
                <ul>
                    <li>Pour la famille CMOS, la sortance n'est pas limitée par les courants puisque le courant d'entrée
                        des portes CMOS est pratiquement nul. Théoriquement, on peut connecter un grand nombre de portes
                        à une sortie unique sans provoquer de surcharge en courant.</li>
                    <li>Cependant, chaque porte connectée ajoute sa capacité d'entrée (environ 7,5 pF), ce qui augmente
                        la capacité totale de charge vue par la sortie. Cette capacité accrue ralentit les temps de
                        propagation des signaux, ce qui peut dégrader les performances globales du circuit, notamment à
                        des fréquences élevées.</li>
                    <li>Dans la pratique, pour éviter une dégradation excessive des temps de propagation, il est
                        recommandé de ne pas dépasser une sortance de 50 portes connectées à une seule sortie. Pour des
                        applications critiques, des circuits de buffer peuvent être utilisés pour augmenter la capacité
                        de décharge sans compromettre les performances.</li>
                </ul>

                <!-- ################################################################################################ -->
                <h3 id="TPROP">Temps de propagation :</h3>
                <img src="IMAGES/EN_FAM_4K_TP_RC.jpg" alt="">
                <p>Le temps de propagation dépend fortement du circuit RC constitué de la résistance \(R_{DS}\) et de
                    la capacité de charge \(C_L\). A chaque basculement, il faut charger ou décharger \(C_L\) à travers
                    la résistance \(R_{DS}\), Le retard est voisin de la constante de temps \(\tau = R_{DS} C_L\). </p>
                <p>La valeur de \(R_{DS}\) dépend de la tension Vgs (donc de Vdd) d'où l'influence de cette dernière sur
                    le temp de propagation</p>
                <img src="IMAGES/EN_FAM_4K_TP_Rds.jpg" alt="">
                <img src="IMAGES/EN_FAM_4K_TP_CRB.jpg" alt="">
                <p>On constate que le temps de propagation est bien meilleur avec Vdd=15V. C'était aussi le cas avec la
                    marge de bruit, il semble donc qu'on a toujours intérêt à suralimenter les circuits CMOS</p> <br>

                <!-- ################################################################################################ -->
                <h3 id="CONSO">Consommation :</h3>
                <ul>
                    <li>En <b>statique</b>, la consommation est quasi nulle. Il n'y a aucun chemin entre Vdd et la masse
                        car un des deux transistors complémentaires est toujours bloqué. </li>
                    <li>Lors d'un basculement (Vi = Vt), on va avoir une petite consommation pour deux raisons:
                        <ul>
                            <li>Les deux transistors conduisent simultanément pendant un très cours instant et un
                                courant circule entre Vdd et la masse</li>
                            <li>A chaque basculement, on charge ou on décharge la capacité C<sub>L</sub></li>
                            <img src="IMAGES/EN_FAM_4K_CONSO.jpg" alt="">
                        </ul>
                    </li>
                    <li>En <b>haute fréquence</b>, on a beaucoup de basculement par seconde, donc la consommation
                        augmente </li>
                </ul>

                <img src="IMAGES/EN_FAM_4K_CONSO_freq.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="74C">Les circuits 74C</h3>
                <p>Les circuits de la famille 74C sont les même que les circuits de la série 4000 avec la nomenclature
                    normalisée. Ils ont le même brochage que la famille TTL.</p>
                <p>Par exemple, le circuit 74C00 contient quatre portes NAND similaires à ceux du 4011, mais il n'ont
                    pas
                    le même brochage.</p>
                <img src="IMAGES/EN_FAM_4K_74C.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="NAND4011">La porte NAND (4011) :</h3>
                <p>Nous en avons déjà parlé dans la section <a href="Elec_Num.html#4011" target="_blank">Transistor MOS
                        en commutation</a></p><br>

                <h3 id="NOR4001">La porte NOR (4001) :</h3>
                <p>Nous en avons déjà parlé dans la section <a href="Elec_Num.html#4001" target="_blank">Transistor MOS
                        en commutation</a></p><br><br>

                <!-- ################################################################################################ -->
                <h2 id="PLDFPGA">Les circuits logique programmables PLD</h2>
                <p>Les circuits logiques programmables <i>(PLD: Programmable Logic Devices)</i> sont des composants
                    électroniques permettant de créer des circuits logiques <b>personnalisés</b>. Contrairement aux
                    circuits logiques fixes (comme les circuits intégrés TTL ou CMOS), les PLD peuvent être programmés
                    pour répondre à des besoins spécifiques.</p>
                <p>Le terme <b>programmable</b> peut prêter à confusion. Les PLD ne sont pas programmés au sens
                    informatique qui consiste à implanter le code d'une application dans un microcontrôleur ou un
                    microprocesseur. Le terme <b>reconfigurable</b> est plus adapté. En effet, un PLD est un
                    circuit intégré qui contient un réseau d'opérateurs logiques de base qui ne <b>sont pas
                        interconnectés lors de la fabrication</b>.
                    L'utilisateur <b>reconfigure</b> le circuit en définissant les connexions entre les les éléments
                    logiques nécessaires pour réaliser une fonction particulière.
                </p><br>

                <!-- ################################################################################################ -->
                <h3 id="PLDTYPES">Types de PLD</h3>
                <p>Beaucoup d'acronymes sont utilisés dans le domaine des PLD. Certains désignent des technologies,
                    d'autre des génération de technologies, etc...</p>
                <ul>
                    <li><em>PLA: </em>(Programmable Logic array) sont les premiers PLD qui ont été développés. Matrice
                        ET programmable, Matrice OU programmable. Permet une flexibilité maximale pour implémenter des
                        fonctions logiques complexes</li>
                    <li><em>PAL: </em>(Programmable Array Logic) Simplification des PLA : seuls les réseaux AND sont
                        programmables. Moins flexible mais plus rapide et plus économique.</li>
                    <li><em>GAL: </em>(Generic Array Logic) Version améliorée et plus flexible des PAL. Il sont
                        <em>RE</em>programmables
                        grâce à leur réseau d'interconnexion de type EEPROM.
                    </li>
                    <li><em>SPLD: </em>(Simple programmable logic device) Désignes les PLD de première
                        génération. Quelques centaines de portes logiques et quelques dizaines bascules: Technologies
                        PLA, PAL et GAL</li>
                    <li><em>EPLD: </em>(Erasable PLD) Terme générique pour désigner les PLD reprogrammable avec
                        effacement par UV </li>
                    <li><em>EEPLD: </em>(Electricaly Erasable PLD) Terme générique pour désigner les PLD reprogrammable
                        électriquement </li>
                    <li><em>CPLD: </em>(complex programmable logic device) Circuits relativement complexes (jusqu'à une
                        ou deux dizaines de milliers de portes). Constitué de blocs logiques programmables dont
                        l'architecture des blocs dérive directement de celle des SPLDs. Peut implémenter
                        des fonctions plus complexes que les PAL. </li>
                    <li><em>FPGA: </em>(field programmable gate array) Circuit qui peut être très complexe. Des
                        centaines de milliers
                        d'éléments logiques, avec des modules plus au moins sophistiqués et de la mémoire intégrée.
                        (Capacité en constante augmentation).
                    </li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="BASEIDEA">L'idée de base, les PLA</h3>
                <p>Un système combinatoire est le plus souvent représenté par des fonctions sous la forme canonique
                    somme. C'est une somme (OR) de produits (AND) des entrées et leurs compléments (NOT)</p>
                <img src="IMAGES/EN_PLD_CANONIC.jpg" alt="">
                <p>On constate que nous avons besoins d'inverseurs, de portes ET, de porte OU et d'un ensemble
                    d'interconnexions</p>
                <p>Le circuit PLD sera donc constitué de :</p>
                <ol>
                    <li>Un ensemble de bornes d'entrée,</li>
                    <li>Un ensemble de buffers qui délivrent les entrées et leurs inverses</li>
                    <li>Un ensemble de portes ET qui constitue la <em>matrice ET</em>
                        <img src="IMAGES/EN_PLD_MAT_ET.jpg" alt="">
                    </li>
                    <li>Un ensemble de portes OU qui constitue la <em>matrice OU</em>
                        <img src="IMAGES/EN_PLD_MAT_OU.jpg" alt="">
                    </li>
                    <li>Un ensemble de bornes de sorties,</li>
                </ol>
                <p>Les deux matrices (ET et OU) sont programmables :</p>
                <ul>
                    <li>Chaque porte de la matrice ET est connectée, via des <b>fusibles</b>, à toutes les entrées et
                        leurs inverses.</li>
                    <li>Chaque porte de la matrice OU est connectée, via des <b>fusibles</b>, à toutes les sorties de
                        la matrice ET</li>
                    <li>Lors de la programmation (reconfiguration), l'utilisateur, à l'aide d'un logiciel et d'un
                        équipement spécialisés (programmeur) configure le circuit en détruisant les fusibles inutiles.
                        Seuls les fusibles nécessaires pour réaliser la fonction logique souhaitée sont conservés</li>
                </ul><br>
                <h4>Simplification de dessin :</h4>
                <p>Pour alléger le dessin, on a adopté la convention ci-dessous :</p>
                <img src="IMAGES/EN_PLD_MAT_SMPL.jpg" alt="">
                <p>Voici la représentation d'un PLA 4 entrées et 3 sortie</p>
                <img src="IMAGES/EN_PLD_PLA_4I3O.jpg" alt=""><br>

                <h4>PLA programmé :</h4>
                <img src="IMAGES/EN_PLS_PLA_Programed.jpg" alt="">
                $$ S_1=AB+\bar{A}\bar{B}\bar{C}\bar{D} $$
                $$ S_2=A\bar{C}+\bar{A}CD+B $$
                $$ S_3=AB+A\bar{C}+\bar{A}\bar{B}\bar{D} $$
                <br>
                <!-- ################################################################################################ -->
                <h3 id="PLDPAL">Les PAL</h3>
                <p>Un PAL (Programmable Array Logic) est un PLA dont seule la matrice ET est programmables. La matrice
                    OU est fixe.</p>
                <img src="IMAGES/EN_PLD_PAL.jpg" alt="">
                <p>Les PAL sont plus économiques mais moins souples. Par exemple, avec le circuit de la figure ci
                    dessous, on ne peut pas synthétiser une fonction constitué de la somme de plus de 4 monômes</p><br>

                <!-- ################################################################################################ -->
                <h3 id="PXFUSE">Points de connexion à fusibles :</h3>
                <img src="IMAGES/EN_PLD_PX_FUSE.jpg" alt="">
                <ul>
                    <li>Des diodes ou des transistors MOS sont utilisés comme point de connexion entre les lignes et les
                        colonnes,</li>
                    <li>A la fabrication, tous les points de connexion (fusibles) sont conducteurs,</li>
                    <li>Lors de la programmation, on détruit les fusibles non désirés par <b>claquage</b>. Cette
                        technique consiste à appliquer pendant un court instant une tension supérieure à la tension de
                        destruction <i>(Break down voltage)</i>. Une fois claqué, le composant ne peut plus conduire, ce
                        qui équivaut à couper la connexion,</li>
                    <li>C'est un processus <b>permanent et irréversible</b>. Les circuits peuvent être programmés <b>une
                            seule fois</b>. On parle de technologie PROM.</li>

                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="PXAFUSE">Points de connexion à anti-fusible</h3>
                <p>Contrairement à un fusible, un <b>anti-fusible</b> est initialement isolant. Lors de la
                    programmation, l'application d'une tension ou d'un courant élevé provoque un court-circuit
                    permanent. Cela établit une connexion électrique là où il n'y en avait pas
                    initialement.</p>
                <p>La figure ci-dessous illustre une des technologies utilisées. Deux conducteurs sont séparés par une
                    couche très mince de matériau isolant (par exemple, du silicium amorphe). Lors de la programmation,
                    l'application d'une tension élevée (environ 20 volts) transforme d'une manière <b>permanente</b> le
                    matériau isolant en conducteur, établissant ainsi une liaison entre les deux conducteurs.</p>
                <img src="IMAGES/EN_PLD_PX_AFUSE.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="PLDGAL">Les GAL :</h3>
                <ul>
                    <li>un GAL <i>(Generic Array Logic)</i> est une version améliorée et plus flexible des PAL,</li>
                    <li>Les GAL sont conçus pour être <em>RE</em>programmables. Ils peuvent être reprogrammés plusieurs
                        fois grâce à leur points de connexion EPLD ou EEPLD,</li>
                    <li>Les GAL sont souvent conçus pour être des remplacements directs des PAL dans les circuits
                        existants, ce qui facilite leur adoption.</li>
                </ul><br>

                <!-- ################################################################################################ -->
                <h3 id="PXEPLD">Point de Connexion EPLD :</h3>
                <ul>
                    <li>Le terme <b>EPLD</b> <i>(Erasable Programmable Logic Device)</i> s'inspire du terme <b>EPROM</b>
                        <i>(Erasable Programmable Read-Only Memory)</i>, car ces circuits utilisent le même type de
                        transistor MOS à grille isolée que les mémoires EPROM.
                    </li>
                    <li>Ces circuits se distinguent par leur capacité à être <b>effaçables</b> par exposition aux rayons
                        <b>ultraviolets</b>, ce qui les rend reprogrammables après effacement.
                    </li>
                    <li>Le point de connexion est basé sur un transistor MOS à <b>grille flottante</b> ou <b>grille
                            isolée</b>. Plus précisément, ce type de transistor comporte deux grilles :
                        <ul>
                            <li>Une <b>grille de contrôle</b>, accessible pour appliquer une tension.</li>
                            <li>Une <b>grille flottante</b>, complètement isolée électriquement et capable de piéger des
                                charges électriques.</li>
                        </ul>
                        <img src="IMAGES/EN_PLD_EPLD.jpg" alt="">
                    </li>
                    <li>Lors de la programmation, une tension appropriée appliquée sur la grille de contrôle génère un
                        effet tunnel (ou injection par effet Fowler-Nordheim), permettant le transfert d'électrons vers
                        la grille flottante. Ces électrons y restent piégés même après suppression de la tension de
                        contrôle, modifiant ainsi l'état du transistor.</li>
                    <li>L'effacement des électrons de la grille flottante se fait par exposition aux rayons
                        ultraviolets, qui fournissent l'énergie nécessaire pour libérer les charges et rétablir l'état
                        initial du transistor. Le boîtier dispose d'une petite fenêtre en verre pour permettre au UV
                        d'atteindre les composants.
                        <img src="IMAGES/EN_PLD_EPLD_Pg.jpg" alt="">
                    </li>
                </ul><br>

                <h4>Utilisation de la grille de contrôle :</h4>
                <p>La grille de contrôle intervient à la fois pendant la phase d'utilisation, la phase de programmation,
                    et la phase d'effacement du circuit.</p><br>

                <h4>Phase d'utilisation :</h4>
                <p>Pendant la phase d'utilisation du circuit, <b>les grilles de contrôles de tous les transistors sont
                        portées à 5 Volts</b>.
                    L'état de chaque transistor dépend de l'état de sa grille flottante :</p>
                <ul>
                    <li><b>Grille flottante non chargée :</b> Le potentiel de 5 V appliqué sur la grille de contrôle
                        crée un champ électrique qui attire les électrons minoritaires du substrat. Cela induit un
                        canal de conduction entre le drain et la source.
                        Résultat : les transistors <b>non programmés</b> fonctionnent comme des <b>points de connexion
                            fermés</b>
                        (ON).
                        <img src="IMAGES/EN_PLD_EPLD_UNP.jpg" alt="">
                    </li>
                    <li><b>Grille flottante chargée :</b> La charge négative présente sur la grille flottante masque
                        l'effet du potentiel de la grille de contrôle.
                        Aucun canal de conduction n'est formé entre le drain et la source.
                        Résultat : les transistors <b>programmés</b> agissent comme des <b>points de connexion
                            ouverts</b> (OFF).
                        <img src="IMAGES/EN_PLD_EPLD_UP.jpg" alt="">
                    </li>
                </ul><br>

                <h4>Phase de programmation :</h4>
                <p>Une tension élevée (&approx; 20 V) est appliquée sur la grille de contrôle du transistor à
                    programmer.
                    Ce fort champ électrique provoque un effet tunnel ou injection par effet Fowler-Nordheim, qui
                    transfère des électrons vers la grille flottante.
                    Les électrons restent piégés sur la grille flottante après la suppression de la tension
                    de contrôle, modifiant définitivement l'état du transistor.</p>
                <img src="IMAGES/EN_PLD_EPLD_Prog.jpg" alt=""><br>

                <h4>Phase d'effacement :</h4>
                <p>Pendant cette phase, le circuit est placé sous une lampe à UV pendant une vingtaine de minutes.
                    Les rayons ultraviolets fournissent l'énergie nécessaire pour libérer les charges et rétablir
                    l'état initial du transistor. Pendant cette phase, le fait de porter la grille de contrôle à un
                    potentiel inférieur à
                    celui du substrat peut faciliter le retour des charges piégées à leur état initial. Une fois les
                    charges éliminées, les transistors retrouvent leur état initial et peuvent être reprogrammés.</p>
                <img src="IMAGES/EN_PLD_EPLD_Erase.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="PXEEPLD">Point de Connexion EEPLD</h3>

                <p>Un point de connexion EEPLD utilise un transistor à grille isolée qui a bénéficié d'un
                    certain nombre d'améliorations technologiques afin qu'il puisse être <b>reprogrammé
                        électriquement</b> sans nécessité d'un effacement par ultra-violets. </p>
                <p>Les principales améliorations pour rendre les transistors à grille isolée effaçables électriquement
                    incluent :</p>
                <ul>
                    <li>Réduction de l'épaisseur de l'isolant entre la grille flottante et le substrat (200 Å),</li>
                    <li>Amélioration des matériaux de l'oxyde isolant par l'utilisation de matériaux à haute
                        permittivité diélectrique (high-k),</li>
                    <li>Optimisation de la grille flottante pour une meilleure rétention des charges.</li>
                </ul>
                <img src="IMAGES/EN_PLD_EEPLD.jpg" alt="">
                <ul>
                    <li>Pour charger la grille flottante, on applique une tension élevée (typiquement entre +15V et
                        +20V) sur la grille de contrôle pour générer un champ électrique suffisant qui provoque un
                        transfert d'électrons vers la grille flottante par effet tunnel,
                        <img src="IMAGES/EN_PLD_EEPLD_Ch.jpg" alt="">
                    </li>
                    <li>Pour retirer les charges piégées dans la grille flottante et ramener le transistor à son état
                        initial, on applique une tension élevée de sens inverse (typiquement entre -15V et -20V) sur la
                        grille de contrôle.
                        Cette tension inverse génère un champ électrique qui extrait les électrons de la grille
                        flottante par effet tunnel.
                        <img src="IMAGES/EN_PLD_EEPLD_Dch.jpg" alt="">
                    </li>
                </ul><br>

                <p>Lors de la phase d'utilisation, le point de connexion EEPLD s'utilise comme le point de connexion
                    EPLD. <b>les grilles de contrôles de tous les transistors sont portées à 5 Volts</b>.
                    L'état de chaque transistor dépend de l'état de sa grille flottante :</p>
                <ul>
                    <li><b>Grille flottante non chargée :</b> Le potentiel de 5 V appliqué sur la grille de contrôle
                        crée un champ électrique qui attire les électrons minoritaires du substrat. Cela induit un
                        canal de conduction entre le drain et la source.
                        Résultat : les transistors <b>non programmés</b> fonctionnent comme des <b>points de connexion
                            fermés</b> (ON).
                        <img src="IMAGES/EN_PLD_EPLD_UNP.jpg" alt="">
                    </li>
                    <li><b>Grille flottante chargée :</b> La charge négative présente sur la grille flottante masque
                        l'effet du potentiel de la grille de contrôle.
                        Aucun canal de conduction n'est formé entre le drain et la source.
                        Résultat : les transistors <b>programmés</b> agissent comme des <b>points de connexion
                            ouverts</b> (OFF).
                        <img src="IMAGES/EN_PLD_EPLD_UP.jpg" alt="">
                    </li>
                </ul><br>
                <!-- ################################################################################################ -->
                <h2 id="IOBLOCS">Les blocs d'Entrée Sortie</h2>
                <p>Les blocs d'entrée/sortie (E/S) des circuits PLD sont des interfaces configurables qui permettent de
                    connecter le circuit à des périphériques externes. Ils peuvent inclure des fonctionnalités telles
                    que des tampons tri-état, des registres de capture, ou des options de polarité, offrant ainsi une
                    grande flexibilité pour s'adapter aux exigences spécifiques des systèmes numériques.</p>

                <!-- ################################################################################################ -->
                <h3 id="3STATEOUT">Sortie 3 états</h3>
                <p>Les sorties sont souvent de type 3 états, ce qui permet de les déconnecter au besoin</p>
                <img src="IMAGES/EN_PLD_3SOUT.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="PLDIO">Entrée Sortie</h3>
                <p>Une entrée-sortie est une broche qui peut être utilisée <b>soit comme entrée soit comme sortie</b>.
                    Elle sert aussi à réinjecter la sortie avec les entrées ce qui permet l'étude des systèmes
                    séquentiels </p>
                <img src="IMAGES/EN_PLD_IO.jpg" alt="">


                <!-- ################################################################################################ -->
                <h3 id="COMBOUT">Sortie combinatoire</h3>
                <p>Un sortie combinatoire peut être active au niveau haut, au niveau bas ou au choix :</p>
                <ul>
                    <li><b>Type H :</b> Sortie active au niveau Haut</li>
                    <img src="IMAGES/EN_PLD_CMBOUT_H.jpg" alt="">
                    <li><b>Type L :</b> Sortie active au niveau bas</li>
                    <img src="IMAGES/EN_PLD_CMBOUT_L.jpg" alt="">
                    <li><b>Type C :</b> Combinée: programmable en type H ou L</li>
                    <img src="IMAGES/EN_PLD_CMBOUT_H.jpg" alt="">

                </ul>
                <!-- ################################################################################################ -->
                <h3 id="REGOUT">Sortie à registre</h3>
                <img src="IMAGES/EN_PLD_REGOUT.jpg" alt="">
                <ul>
                    <li>La sortie est mémorisée dans une bascule,</li>
                    <li>Dans certaines versions, La bascule dispose d'entrées de forçage asynchrones, (Clear, Preset)
                    </li>
                    <li>Dans certaines versions, un XOR d'inversion programmable est inséré juste derrière la porte OR
                    </li>
                </ul>
                <!-- ################################################################################################ -->
                <h3 id="VERSOUT">Sortie versatile</h3>
                <img src="IMAGES/EN_PLD_VERSOUT.jpg" alt="">
                <p>E/S très souple qui peut être configurée dans différents modes en programmant les fusibles S0 et S1
                </p>
                <img src="IMAGES/EN_PLD_VERSOUT_Tab.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h3 id="PAL16L8">Le circuit PAL16L8</h3>
                <p>C'est un circuit à sorties combinatoires (active Low). La référence est un peu trompeuse car elle
                    précise 16 entrées et 8 sorties. En réalité, les sorties sont des E/S et sont comptées avec les
                    entrée. Pour être précis, le circuit dispose de 10 entrées pures, 2 sorties pures et 6
                    Entrée-sorties.</p>
                <img src="IMAGES/EN_PLD_P16L8.jpg" alt="">
                <img src="IMAGES/EN_PLD_P16L8_Ch.jpg" alt="">

                <!-- ################################################################################################ -->
                <h3 id="GAL22V10">Le circuit GAL22V10</h3>
                <p>Le circuit GAL22V10 était populaire à son époque. Il est reprogrammable grace à ses point de
                    connexion de type EEPLD. Il dispose de 12 Entrée et de 10 E/S Versatiles</p>
                <img src="IMAGES/EN_PLD_GAL22V10.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id="CPLD">Les CPLD</h2>
                <p>Les CPLD (circuits logiques programmables <b>complexes</b> ) constituent
                    une évolution des circuits logiques programmables simples (comme les PAL et GAL) en offrant une
                    capacité de logique plus importante et une flexibilité accrue. Voici quelques propriétés :</p>
                <ul>
                    <li>Ils sont essentiellement de technologie EEPLD. Il sont non volatiles et reprogrammables </li>
                    <li>Ils permette de réaliser des systèmes assez complexes: USART, contrôleur LAN, contrôleur
                        graphique, contrôleur cache …</li>
                    <li>Il sont caractérisés par un temps de propagation court et prédictible dû la structure
                        d'interconnexion unique, </li>
                    <li>Le nombre de LABs dans un circuit dépend des familles. Une dizaine à plusieurs centaines</li>
                </ul>
                <h3>Structure d'un circuit CPLD :</h3>
                <p>Un CPLD est constitué de trois ensembles principaux :</p>
                <ul>
                    <li>Plusieurs blocs de type PLD appelés LAB <i><b>(Logic Array Bloc)</b></i>. Chaque bloc (LAB)
                        est constitué d'un ensemble de macrocellules permettant chacune de synthétiser une fonction
                        logique comme c'est le cas
                        dans un circuit 22V10 par exemple,
                    </li>
                    <li>Quelques blocs d'E/S pour se connecter à l'extérieure,</li>
                    <li>Une matrice d'interconnection permettant de relier les LABs entre eux et avec les E/S. Elle est
                        appelée PI ou PIA <i><b>(Programmable Interconnect array)</b></i> </li>
                </ul>
                <img src="IMAGES/EN_PLD_CPLD.jpg" alt=""><br>

                <h3>Structure d'un LAB :</h3>
                <p>Chaque LAB est constitué de plusieurs <b>macrocellules</b> de type SPLD (16 en général).</p>
                <img src="IMAGES/EN_PLD_CPLD_LABstruc.jpg" alt="">
                <p>Les macrocellules constituants les LAB CPLD sont plus élaborées que celles des SPLD.</p>
                <p>Dans un PAL classique, chaque somme (OU) est connectée à un à un nombre fixe de produits (ET).
                    Cependant, toutes ces produits ne sont pas toujours nécessaires pour synthétiser une fonction
                    logique. Si
                    tous les produits ne sont pas utilisés, ces ressources restent gaspillées.</p>
                <img src="IMAGES/EN_PLD_REGOUT.jpg" alt="">
                <p>Dans les macrocellules d'un LAB CPLD, on a ajouté une matrice de sélection de Produits <i>(PTC -
                        Product-Term Select Matrix)</i>, qui permet de rediriger les produits (ET)
                    non utilisés vers d'autres macrocellules, ou si nécessaire,
                    d'injecter des produits venant d'autre macrocellules. Ceci permet d' obtenir un meilleur taux
                    d'utilisations des ressources.</p>
                <img src="IMAGES/EN_PLD_CPLD_MCell.jpg" alt=""><br>

                <!-- ################################################################################################ -->
                <h2 id="FPGA">Les FPGA</h2>

                <p>La technologie <b>FPGA : Field-Programmable Gate Array</b> est la catégorie de PLD la plus développée
                    et la plus utilisée de nos jours. Sa capacité et ses performances sont bien supérieures à celles de
                    la technologie CPLD. Les circuit FPGA sont plus flexibles et peuvent être configurés plusieurs
                    fois, même après leur mise en service. Ils sont largement utilisés pour des applications complexes
                    telles que le traitement du signal, les systèmes embarqués, en phase de prototypage et en produit
                    final.</p>
                <p>Parmi les caractéristiques principales des circuits FPGA on peut citer :</p>
                <ul>
                    <li>Un circuit FPGA est constitué d'un grand nombre de blocs logiques programmables appelés CLB
                        (Configurable Logic Blocks). Ces blocs sont répartis sur toute la surface de la puce et
                        "baignent" dans une matrice d'interconnexion programmable, également distribuée sur toute la
                        surface. Cette matrice permet de connecter les CLB entre eux et de les interfacer avec les blocs
                        d'E/S programmables (IO ou IOB) qui entourent l'ensemble.

                        Bien que les exigences de routage varient d'un circuit à l'autre, certaines caractéristiques
                        communes peuvent être exploitées pour concevoir de manière optimale cette interconnexion. Par
                        exemple, la plupart des conceptions présentent une certaine localité, ce qui nécessite une
                        abondance de fils courts pour relier les CLB voisins. Cependant, il existe également des
                        connexions à longue distance, ce qui implique le besoin de fils longs mais moins nombreux.

                        En outre, la matrice d'interconnexion des FPGA est conçue de manière hiérarchique, avec des
                        réseaux locaux pour connecter des blocs proches et des réseaux globaux pour relier des blocs
                        plus éloignés. Cette architecture hiérarchique optimise l'utilisation des ressources et réduit
                        les délais de propagation, ce qui en fait une solution adaptée aux conceptions complexes et
                        dynamiques. </li>
                    <img src="IMAGES/EN_PLD_FPGA.jpg" alt="">
                    <li>La technologie FPGA a adopté le transistor MOS (normal) comme point de connexion. Ce choix
                        présente plusieurs avantages : il est facile à fabriquer, et sa petite taille permet un taux
                        d'intégration élevé. Cependant, le transistor MOS seul n'a pas de capacité de mémoire, l'état de
                        chaque transistor étant uniquement défini par la tension de commande appliquée à sa grille.

                        Pour pallier cette limitation, les circuits FPGA utilisent des cellules mémoire SRAM pour
                        contrôler les grilles des transistors MOS. Ces cellules SRAM constituent la mémoire de
                        configuration du circuit et définissent le comportement logique du FPGA. Cependant, les cellules
                        SRAM sont volatiles, ce qui signifie qu'elles perdent leur état lorsque l'alimentation est
                        coupée.

                        Pour assurer la non-volatilité des données de configuration, les FPGA s'appuient sur une mémoire
                        externe non volatile, généralement une EEPROM ou une mémoire flash. Lors de la programmation,
                        les données de configuration sont enregistrées dans cette mémoire externe. Ainsi, à chaque mise
                        sous tension du FPGA, l'ensemble de sa mémoire de configuration est initialisé à partir de la
                        mémoire non volatile, permettant au circuit de retrouver son fonctionnement prévu. Cette
                        approche combine la flexibilité de la reprogrammation avec la fiabilité des mémoires non
                        volatiles.
                        <img src="IMAGES/EN_PLD_FPGA_PXMOS.jpg" alt="">
                        Pour une mailleur souplesse de la matrice de connexion, chaque point de connexion peut être
                        constitué de plusieurs MOS (jusqu'à 6) pour augmenter le nombre de possibilités
                        d'interconnexion.
                        <img src="IMAGES/EN_PLD_FPGA_PXMOS_6.jpg" alt="">
                    </li>
                    <li> Un bloc CLB (Configurable Logic Block) est constitué de plusieurs éléments logiques (LE : Logic
                        Element). Un LE est composé d'un bloc combinatoire permettant de réaliser une fonction logique,
                        suivi d'une bascule servant à la mémorisation ou à la synchronisation des données. <br>

                        Le bloc CLB d'un FPGA est généralement plus petit qu'un bloc logique de CPLD, mais une puce FPGA
                        contient beaucoup plus de blocs que ce que peut offrir un CPLD de taille équivalente (die size).
                        La taille des blocs CLB détermine la granularité, qui peut être plus ou moins fine dans un FPGA.
                        Une granularité fine améliore le taux d'utilisation des ressources logiques du circuit, mais
                        elle augmente les besoins en ressources d'interconnexion. Dans le cas d'une granularité très
                        fine, un bloc peut être réduit à un seul LE, consistant uniquement en un petit bloc combinatoire
                        et une bascule.
                        Cette configuration offre une grande flexibilité, mais impose une gestion optimisée de
                        l'interconnexion pour éviter une augmentation des délais de propagation et de la consommation
                        énergétique.
                    </li>
                </ul><br>

                <h3>Cellule SRAM :</h3>
                <p>La cellule SRAM est réalisé à l'aide de transistors MOS. Elle est constituée de deux inverseurs monté
                    tête-bêche</p>
                <img src="IMAGES/EN_PLD_FPGA_SRAM_Cell.jpg" alt="">

                <h3>Le LUT : Look Up Table</h3>
                <p>Dans un FPGA, le bloc combinatoire n'est pas réalisé par une matrice de portes ET et OU, comme c'est
                    le cas des PLD classiques. Au lieu de cela, on utilise un LUT (Look-Up Table) pour accomplir cette
                    tâche. <br>

                    Un LUT est un multiplexeur conçu pour implémenter une fonction logique. Les entrées du multiplexeur
                    sont connectées à une mémoire SRAM préprogrammée avec la table de vérité de la fonction logique à
                    réaliser. Les variables de la fonction servent à commander les lignes de sélection du multiplexeur,
                    permettant ainsi de produire la sortie logique correspondante.
                </p>
                <img src="IMAGES/EN_PLD_FPGA_LUT.jpg" alt=""><br>

                <p>La réalisation des multiplexeurs se fait entièrement à l'aide de transistor MOS. On commence par
                    réaliser un multiplexeur 2:1 à l'aide de quatre transistor MOS (inverseur = deux transistors)</p>
                <img src="IMAGES/EN_PLD_FPGA_MXR21.jpg" alt="">
                <p>L'association en pyramide des multiplexeurs 2:1 permet d'obtenir des multiplexeurs plus grads</p>
                <img src="IMAGES/EN_PLD_FPGA_MXR81.jpg" alt=""> <br>

                <h3>Exemple d'un LE</h3>
                <p>C'est exemple montre un LE du constructeur Altera. Il est conçu pour offrir une grande souplesse d'utilisation</p>
                <img src="IMAGES/EN_PLD_FPGA_LE0.jpg" alt="">
                
                <ol>
                    <li>Bloc combinatoire constitué d'un LUT et d'un bloc Carry pour l'extension</li>
                    <li>La bascule peut être programmée en bascule D, T, JK ou RS</li>
                    <li>CLR, PRESET, Chargement Asynchrones</li>
                    <li>Horloge et Validation d’horloge</li>
                    <li>Chargement Synchrone</li>
                    <li>La sortie de la bascule peut être envoyée vers le réseau d’interconnexion ou réinjectée à
                        l’entrée du bloc combinatoire</li>
                    <li>On peut utiliser seulement le bloc combinatoire sans passer par la bascule</li>
                    <img src="IMAGES/EN_PLD_FPGA_LE1.jpg" alt="">
                    <li>On peut utiliser la bascule seule sans passer par le bloc combinatoire</li>
                    <li>La bascule peut être chaînée avec d’autres bascules pour faire des registres à décalage par
                        exemple</li>
                    <img src="IMAGES/EN_PLD_FPGA_LE2.jpg" alt="">
                    <li>Le LUT et le registre peuvent être utilisés séparément mais simultanément</li>
                </ol><br>

                <h3>Exemple d'un Bloc d'E/S (IOB)</h3>
                <img src="IMAGES/EN_PLD_FPGA_IOB.jpg" alt="">


                <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>



            </div>
        </div>
    </div>
</body>

</html>